{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>PR-Agent is an open-source tool to help efficiently review and handle pull requests.  Qodo Merge is a hosted version of PR-Agent, designed for companies and teams that require additional features and capabilities</p> <ul> <li> <p>See the Installation Guide for instructions on installing and running the tool on different git platforms.</p> </li> <li> <p>See the Usage Guide for instructions on running commands via different interfaces, including CLI, online usage, or by automatically triggering them when a new PR is opened.</p> </li> <li> <p>See the Tools Guide for a detailed description of the different tools.</p> </li> </ul>"},{"location":"#docs-smart-search","title":"Docs Smart Search","text":"<p>To search the documentation site using natural language:</p> <p>1) Comment <code>/help \"your question\"</code> in either:</p> <ul> <li>A pull request where Qodo Merge is installed</li> <li>A PR Chat</li> </ul> <p>2) The bot will respond with an answer that includes relevant documentation links.</p>"},{"location":"#qodo-merge-features","title":"Qodo Merge Features","text":"<p>Qodo Merge offers extensive pull request functionalities across various git providers:</p> GitHub Gitlab Bitbucket Azure DevOps TOOLS Review \u2705 \u2705 \u2705 \u2705 \u2b91 Incremental \u2705 Ask \u2705 \u2705 \u2705 \u2705 Describe \u2705 \u2705 \u2705 \u2705 \u2b91 Inline file summary \ud83d\udc8e \u2705 \u2705 \u2705 Improve \u2705 \u2705 \u2705 \u2705 \u2b91 Extended \u2705 \u2705 \u2705 \u2705 Auto-Approve \ud83d\udc8e \u2705 \u2705 \u2705 Custom Prompt \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Reflect and Review \u2705 \u2705 \u2705 \u2705 Update CHANGELOG.md \u2705 \u2705 \u2705 \ufe0f Find Similar Issue \u2705 \ufe0f Add PR Documentation \ud83d\udc8e \u2705 \u2705 \u2705 Generate Custom Labels \ud83d\udc8e \u2705 \u2705 \u2705 Analyze PR Components \ud83d\udc8e \u2705 \u2705 \u2705 Test \ud83d\udc8e \u2705 \u2705 Implement \ud83d\udc8e \u2705 \u2705 \u2705 \ufe0f USAGE CLI \u2705 \u2705 \u2705 \u2705 App / webhook \u2705 \u2705 \u2705 \u2705 Actions \u2705 \ufe0f CORE PR compression \u2705 \u2705 \u2705 \u2705 Repo language prioritization \u2705 \u2705 \u2705 \u2705 Adaptive and token-aware file patch fitting \u2705 \u2705 \u2705 \u2705 Multiple models support \u2705 \u2705 \u2705 \u2705 Static code analysis \ud83d\udc8e \u2705 \u2705 Multiple configuration options \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 <p>\ud83d\udc8e marks a feature available only in Qodo Merge, and not in the open-source version.</p>"},{"location":"#example-results","title":"Example Results","text":""},{"location":"#describe","title":"/describe","text":""},{"location":"#review","title":"/review","text":""},{"location":"#improve","title":"/improve","text":""},{"location":"#generate_labels","title":"/generate_labels","text":""},{"location":"#how-it-works","title":"How it Works","text":"<p>The following diagram illustrates Qodo Merge tools and their flow:</p> <p></p> <p>Check out the PR Compression strategy page for more details on how we convert a code diff to a manageable LLM prompt</p>"},{"location":"ai_search/","title":"AI Docs Search","text":"AI Docs Search <p>         Search through our documentation using AI-powered natural language queries.     </p> Search"},{"location":"chrome-extension/","title":"Qodo Merge Chrome Extension","text":"<p>Qodo Merge Chrome extension is a collection of tools that integrates seamlessly with your GitHub environment, aiming to enhance your Git usage experience, and providing AI-powered capabilities to your PRs.</p> <p>With a single-click installation you will gain access to a context-aware chat on your pull requests code, a toolbar extension with multiple AI feedbacks, Qodo Merge filters, and additional abilities.</p> <p>The extension is powered by top code models like Claude 3.5 Sonnet and GPT4. All the extension's features are free to use on public repositories.</p> <p>For private repositories, you will need to install Qodo Merge in addition to the extension  (Quick GitHub app setup with a 14-day free trial. No credit card needed). For a demonstration of how to install Qodo Merge and use it with the Chrome extension, please refer to the tutorial video at the provided link.</p> <p></p>"},{"location":"chrome-extension/#supported-browsers","title":"Supported browsers","text":"<p>The extension is supported on all Chromium-based browsers, including Google Chrome, Arc, Opera, Brave, and Microsoft Edge.</p>"},{"location":"chrome-extension/data_privacy/","title":"Data Privacy","text":"<p>We take your code's security and privacy seriously:</p> <ul> <li>The Chrome extension will not send your code to any external servers.</li> <li>For private repositories, we will first validate the user's identity and permissions. After authentication, we generate responses using the existing Qodo Merge integration.</li> </ul>"},{"location":"chrome-extension/features/","title":"Features","text":""},{"location":"chrome-extension/features/#pr-chat","title":"PR chat","text":"<p>The PR-Chat feature allows to freely chat with your PR code, within your GitHub environment. It will seamlessly use the PR as context to your chat session, and provide AI-powered feedback.</p> <p>To enable private chat, simply install the Qodo Merge Chrome extension. After installation, each PR's file-changed tab will include a chat box, where you may ask questions about your code. This chat session is private, and won't be visible to other users.</p> <p>All open-source repositories are supported. For private repositories, you will also need to install Qodo Merge. After installation, make sure to open at least one new PR to fully register your organization. Once done, you can chat with both new and existing PRs across all installed repositories.</p>"},{"location":"chrome-extension/features/#context-aware-pr-chat","title":"Context-aware PR chat","text":"<p>Qodo Merge constructs a comprehensive context for each pull request, incorporating the PR description, commit messages, and code changes with extended dynamic context. This contextual information, along with additional PR-related data, forms the foundation for an AI-powered chat session. The agent then leverages this rich context to provide intelligent, tailored responses to user inquiries about the pull request.</p> <p> </p>"},{"location":"chrome-extension/features/#toolbar-extension","title":"Toolbar extension","text":"<p>With Qodo Merge Chrome extension, it's easier than ever to interactively configure and experiment with the different tools and configuration options.</p> <p>For private repositories, after you found the setup that works for you, you can also easily export it as a persistent configuration file, and use it for automatic commands.</p> <p></p> <p></p>"},{"location":"chrome-extension/features/#qodo-merge-filters","title":"Qodo Merge filters","text":"<p>Qodo Merge filters is a sidepanel option. that allows you to filter different message in the conversation tab.</p> <p>For example, you can choose to present only message from Qodo Merge, or filter those messages, focusing only on user's comments.</p> <p></p> <p></p>"},{"location":"chrome-extension/features/#enhanced-code-suggestions","title":"Enhanced code suggestions","text":"<p>Qodo Merge Chrome extension adds the following capabilities to code suggestions tool's comments:</p> <ul> <li>Auto-expand the table when you are viewing a code block, to avoid clipping.</li> <li>Adding a \"quote-and-reply\" button, that enables to address and comment on a specific suggestion (for example, asking the author to fix the issue)</li> </ul> <p></p> <p></p>"},{"location":"core-abilities/","title":"Core Abilities","text":"<p>Qodo Merge utilizes a variety of core abilities to provide a comprehensive and efficient code review experience. These abilities include:</p> <ul> <li>Fetching ticket context</li> <li>Auto best practices</li> <li>Local and global metadata</li> <li>Dynamic context</li> <li>Self-reflection</li> <li>Impact evaluation</li> <li>Interactivity</li> <li>Compression strategy</li> <li>Code-oriented YAML</li> <li>Static code analysis</li> <li>Code fine-tuning benchmark</li> </ul>"},{"location":"core-abilities/#blogs","title":"Blogs","text":"<p>Here are some additional technical blogs from Qodo, that delve deeper into the core capabilities and features of Large Language Models (LLMs) when applied to coding tasks. These resources provide more comprehensive insights into leveraging LLMs for software development.</p>"},{"location":"core-abilities/#code-generation-and-llms","title":"Code Generation and LLMs","text":"<ul> <li>Effective AI code suggestions: less is more</li> <li>State-of-the-art Code Generation with AlphaCodium \u2013 From Prompt Engineering to Flow Engineering</li> <li>RAG for a Codebase with 10k Repos</li> </ul>"},{"location":"core-abilities/#development-processes","title":"Development Processes","text":"<ul> <li>Understanding the Challenges and Pain Points of the Pull Request Cycle</li> <li>Introduction to Code Coverage Testing</li> </ul>"},{"location":"core-abilities/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Reduce Your Costs by 30% When Using GPT for Python Code</li> </ul>"},{"location":"core-abilities/auto_best_practices/","title":"Auto Best Practices \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub</code></p>"},{"location":"core-abilities/auto_best_practices/#overview","title":"Overview","text":"<p>Note - enabling a Wiki is required for this feature.</p>"},{"location":"core-abilities/auto_best_practices/#finding-code-problems-exploration-phase","title":"Finding Code Problems - Exploration Phase","text":"<p>The <code>improve</code> tool identifies potential issues, problems and bugs in Pull Request (PR) code changes.  Rather than focusing on minor issues like code style or formatting, the tool intelligently analyzes code to detect meaningful problems. </p> <p>The analysis intentionally takes a flexible, exploratory approach to identify meaningful potential issues, allowing the tool to surface relevant code suggestions without being constrained by predefined categories.</p>"},{"location":"core-abilities/auto_best_practices/#tracking-implemented-suggestions","title":"Tracking Implemented Suggestions","text":"<p>Qodo Merge features a novel tracking system that automatically detects when PR authors implement AI-generated code suggestions.  All accepted suggestions are aggregated in a repository-specific wiki page called <code>.pr_agent_accepted_suggestions</code></p>"},{"location":"core-abilities/auto_best_practices/#learning-and-applying-auto-best-practices","title":"Learning and Applying Auto Best Practices","text":"<p>Monthly, Qodo Merge analyzes the collection of accepted suggestions to generate repository-specific best practices, stored in <code>.pr_agent_auto_best_practices</code> wiki file. These best practices reflect recurring patterns in accepted code improvements.</p> <p>The <code>improve</code> tool will incorporate these best practices as an additional analysis layer, checking PR code changes against known patterns of previously accepted improvements. This creates a two-phase analysis:</p> <ol> <li>Open exploration for general code issues</li> <li>Targeted checking against established best practices - exploiting the knowledge gained from past suggestions</li> </ol> <p>By keeping these phases decoupled, the tool remains free to discover new or unseen issues and problems, while also learning from past experiences.</p> <p>When presenting the suggestions generated by the <code>improve</code> tool, Qodo Merge will add a dedicated label for each suggestion generated from the auto best practices - 'Learned best practice':</p> <p></p>"},{"location":"core-abilities/auto_best_practices/#auto-best-practices-vs-custom-best-practices","title":"Auto Best Practices vs Custom Best Practices","text":"<p>Teams and companies can also manually define their own custom best practices in Qodo Merge. </p> <p>When custom best practices exist, Qodo Merge will still generate an 'auto best practices' wiki file, though it won't be used by the <code>improve</code> tool.  However, this auto-generated file can still serve two valuable purposes:</p> <ol> <li>It can help enhance your custom best practices with additional insights derived from suggestions your team found valuable enough to implement</li> <li>It demonstrates effective patterns for writing AI-friendly best practices</li> </ol> <p>Even when using custom best practices, we recommend regularly reviewing the auto best practices file to refine your custom rules.</p>"},{"location":"core-abilities/auto_best_practices/#relevant-configurations","title":"Relevant configurations","text":"<pre><code>[auto_best_practices]\n# Disable all auto best practices usage or generation\nenable_auto_best_practices = true  \n\n# Disable usage of auto best practices file in the 'improve' tool\nutilize_auto_best_practices = true \n\n# Extra instructions to the auto best practices generation prompt\nextra_instructions = \"\"            \n\n# Max number of patterns to be detected\nmax_patterns = 5                   \n</code></pre>"},{"location":"core-abilities/code_oriented_yaml/","title":"Code-oriented YAML","text":""},{"location":"core-abilities/code_oriented_yaml/#overview","title":"Overview","text":"<p>TBD</p>"},{"location":"core-abilities/compression_strategy/","title":"Compression strategy","text":""},{"location":"core-abilities/compression_strategy/#overview-pr-compression-strategy","title":"Overview - PR Compression Strategy","text":"<p>There are two scenarios:</p> <ol> <li>The PR is small enough to fit in a single prompt (including system and user prompt)</li> <li>The PR is too large to fit in a single prompt (including system and user prompt)</li> </ol> <p>For both scenarios, we first use the following strategy</p>"},{"location":"core-abilities/compression_strategy/#repo-language-prioritization-strategy","title":"Repo language prioritization strategy","text":"<p>We prioritize the languages of the repo based on the following criteria:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>Given the main languages used in the repo</li> <li>We sort the PR files by the most common languages in the repo (in descending order):</li> <li><code>[[file.py, file2.py],[file3.js, file4.jsx],[readme.md]]</code></li> </ol>"},{"location":"core-abilities/compression_strategy/#small-pr","title":"Small PR","text":"<p>In this case, we can fit the entire PR in a single prompt: 1. Exclude binary files and non code files (e.g. images, pdfs, etc) 2. We Expand the surrounding context of each patch to 3 lines above and below the patch</p>"},{"location":"core-abilities/compression_strategy/#large-pr","title":"Large PR","text":""},{"location":"core-abilities/compression_strategy/#motivation","title":"Motivation","text":"<p>Pull Requests can be very long and contain a lot of information with varying degree of relevance to the pr-agent. We want to be able to pack as much information as possible in a single LMM prompt, while keeping the information relevant to the pr-agent.</p>"},{"location":"core-abilities/compression_strategy/#compression-strategy","title":"Compression strategy","text":"<p>We prioritize additions over deletions:  - Combine all deleted files into a single list (<code>deleted files</code>)  - File patches are a list of hunks, remove all hunks of type deletion-only from the hunks in the file patch</p>"},{"location":"core-abilities/compression_strategy/#adaptive-and-token-aware-file-patch-fitting","title":"Adaptive and token-aware file patch fitting","text":"<p>We use tiktoken to tokenize the patches after the modifications described above, and we use the following strategy to fit the patches into the prompt:</p> <ol> <li>Within each language we sort the files by the number of tokens in the file (in descending order):<ul> <li><code>[[file2.py, file.py],[file4.jsx, file3.js],[readme.md]]</code></li> </ul> </li> <li>Iterate through the patches in the order described above</li> <li>Add the patches to the prompt until the prompt reaches a certain buffer from the max token length</li> <li>If there are still patches left, add the remaining patches as a list called <code>other modified files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> <li>If we haven't reached the max token length, add the <code>deleted files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> </ol>"},{"location":"core-abilities/compression_strategy/#example","title":"Example","text":""},{"location":"core-abilities/dynamic_context/","title":"Dynamic context","text":""},{"location":"core-abilities/dynamic_context/#tldr","title":"TL;DR","text":"<p>Qodo Merge uses an asymmetric and dynamic context strategy to improve AI analysis of code changes in pull requests. It provides more context before changes than after, and dynamically adjusts the context based on code structure (e.g., enclosing functions or classes). This approach balances providing sufficient context for accurate analysis, while avoiding needle-in-the-haystack information overload that could degrade AI performance or exceed token limits.</p>"},{"location":"core-abilities/dynamic_context/#introduction","title":"Introduction","text":"<p>Pull request code changes are retrieved in a unified diff format, showing three lines of context before and after each modified section, with additions marked by '+' and deletions by '-'. <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n\n@@ -26,2 +26,4 @@ def func2():\n...\n</code></pre></p> <p>This unified diff format can be challenging for AI models to interpret accurately, as it provides limited context for understanding the full scope of code changes. The presentation of code using '+', '-', and ' ' symbols to indicate additions, deletions, and unchanged lines respectively also differs from the standard code formatting typically used to train AI models.</p>"},{"location":"core-abilities/dynamic_context/#challenges-of-expanding-the-context-window","title":"Challenges of expanding the context window","text":"<p>While expanding the context window is technically feasible, it presents a more fundamental trade-off:</p> <p>Pros:</p> <ul> <li>Enhanced context allows the model to better comprehend and localize the code changes, results (potentially) in more precise analysis and suggestions. Without enough context, the model may struggle to understand the code changes and provide relevant feedback.</li> </ul> <p>Cons:</p> <ul> <li> <p>Excessive context may overwhelm the model with extraneous information, creating a \"needle in a haystack\" scenario where focusing on the relevant details (the code that actually changed) becomes challenging. LLM quality is known to degrade when the context gets larger. Pull requests often encompass multiple changes across many files, potentially spanning hundreds of lines of modified code. This complexity presents a genuine risk of overwhelming the model with excessive context.</p> </li> <li> <p>Increased context expands the token count, increasing processing time and cost, and may prevent the model from processing the entire pull request in a single pass.</p> </li> </ul>"},{"location":"core-abilities/dynamic_context/#asymmetric-and-dynamic-context","title":"Asymmetric and dynamic context","text":"<p>To address these challenges, Qodo Merge employs an asymmetric and dynamic context strategy, providing the model with more focused and relevant context information for each code change.</p> <p>Asymmetric:</p> <p>We start by recognizing that the context preceding a code change is typically more crucial for understanding the modification than the context following it. Consequently, Qodo Merge implements an asymmetric context policy, decoupling the context window into two distinct segments: one for the code before the change and another for the code after.</p> <p>By independently adjusting each context window, Qodo Merge can supply the model with a more tailored and pertinent context for individual code changes.</p> <p>Dynamic:</p> <p>We also employ a \"dynamic\" context strategy. We start by recognizing that the optimal context for a code change often corresponds to its enclosing code component (e.g., function, class), rather than a fixed number of lines. Consequently, we dynamically adjust the context window based on the code's structure, ensuring the model receives the most pertinent information for each modification.</p> <p>To prevent overwhelming the model with excessive context, we impose a limit on the number of lines searched when identifying the enclosing component. This balance allows for comprehensive understanding while maintaining efficiency and limiting context token usage.</p>"},{"location":"core-abilities/dynamic_context/#appendix-relevant-configuration-options","title":"Appendix - relevant configuration options","text":"<pre><code>[config]\npatch_extension_skip_types =[\".md\",\".txt\"]  # Skip files with these extensions when trying to extend the context\nallow_dynamic_context=true                  # Allow dynamic context extension\nmax_extra_lines_before_dynamic_context = 8  # will try to include up to X extra lines before the hunk in the patch, until we reach an enclosing function or class\npatch_extra_lines_before = 3                # Number of extra lines (+3 default ones) to include before each hunk in the patch\npatch_extra_lines_after = 1                 # Number of extra lines (+3 default ones) to include after each hunk in the patch\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/","title":"Fetching Ticket Context for PRs","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/fetching_ticket_context/#overview","title":"Overview","text":"<p>Qodo Merge PR Agent streamlines code review workflows by seamlessly connecting with multiple ticket management systems. This integration enriches the review process by automatically surfacing relevant ticket information and context alongside code changes.</p>"},{"location":"core-abilities/fetching_ticket_context/#ticket-systems-supported","title":"Ticket systems supported","text":"<ul> <li>GitHub</li> <li>Jira (\ud83d\udc8e)</li> </ul> <p>Ticket data fetched:</p> <ol> <li>Ticket Title</li> <li>Ticket Description</li> <li>Custom Fields (Acceptance criteria)</li> <li>Subtasks (linked tasks)</li> <li>Labels</li> <li>Attached Images/Screenshots</li> </ol>"},{"location":"core-abilities/fetching_ticket_context/#affected-tools","title":"Affected Tools","text":"<p>Ticket Recognition Requirements:</p> <ul> <li>The PR description should contain a link to the ticket or if the branch name starts with the ticket id / number.</li> <li>For Jira tickets, you should follow the instructions in Jira Integration in order to authenticate with Jira.</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#describe-tool","title":"Describe tool","text":"<p>Qodo Merge PR Agent will recognize the ticket and use the ticket content (title, description, labels) to provide additional context for the code changes. By understanding the reasoning and intent behind modifications, the LLM can offer more insightful and relevant code analysis.</p>"},{"location":"core-abilities/fetching_ticket_context/#review-tool","title":"Review tool","text":"<p>Similarly to the <code>describe</code> tool, the <code>review</code> tool will use the ticket content to provide additional context for the code changes.</p> <p>In addition, this feature will evaluate how well a Pull Request (PR) adheres to its original purpose/intent as defined by the associated ticket or issue mentioned in the PR description. Each ticket will be assigned a label (Compliance/Alignment level), Indicates the degree to which the PR fulfills its original purpose, Options: Fully compliant, Partially compliant or Not compliant.</p> <p></p> <p>By default, the tool will automatically validate if the PR complies with the referenced ticket. If you want to disable this feedback, add the following line to your configuration file:</p> <pre><code>[pr_reviewer]\nrequire_ticket_analysis_review=false\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#providers","title":"Providers","text":""},{"location":"core-abilities/fetching_ticket_context/#github-issues-integration","title":"Github Issues Integration","text":"<p>Qodo Merge PR Agent will automatically recognize Github issues mentioned in the PR description and fetch the issue content. Examples of valid GitHub issue references:</p> <ul> <li><code>https://github.com/&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;/issues/&lt;ISSUE_NUMBER&gt;</code></li> <li><code>#&lt;ISSUE_NUMBER&gt;</code></li> <li><code>&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;#&lt;ISSUE_NUMBER&gt;</code></li> </ul> <p>Since Qodo Merge PR Agent is integrated with GitHub, it doesn't require any additional configuration to fetch GitHub issues.</p>"},{"location":"core-abilities/fetching_ticket_context/#jira-integration","title":"Jira Integration \ud83d\udc8e","text":"<p>We support both Jira Cloud and Jira Server/Data Center. To integrate with Jira, you can link your PR to a ticket using either of these methods:</p> <p>Method 1: Description Reference:</p> <p>Include a ticket reference in your PR description using either the complete URL format https://.atlassian.net/browse/ISSUE-123 or the shortened ticket ID ISSUE-123. <p>Method 2: Branch Name Detection:</p> <p>Name your branch with the ticket ID as a prefix (e.g., <code>ISSUE-123-feature-description</code> or <code>ISSUE-123/feature-description</code>).</p> <p>Jira Base URL</p> <p>For shortened ticket IDs or branch detection (method 2), you must configure the Jira base URL in your configuration file under the [jira] section:</p> <pre><code>[jira]\njira_base_url = \"https://&lt;JIRA_ORG&gt;.atlassian.net\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#jira-cloud","title":"Jira Cloud \ud83d\udc8e","text":"<p>There are two ways to authenticate with Jira Cloud:</p> <p>1) Jira App Authentication</p> <p>The recommended way to authenticate with Jira Cloud is to install the Qodo Merge app in your Jira Cloud instance. This will allow Qodo Merge to access Jira data on your behalf.</p> <p>Installation steps:</p> <ol> <li> <p>Click here to install the Qodo Merge app in your Jira Cloud instance, click the <code>accept</code> button. </p> </li> <li> <p>After installing the app, you will be redirected to the Qodo Merge registration page. and you will see a success message. </p> </li> <li> <p>Now you can use the Jira integration in Qodo Merge PR Agent.</p> </li> </ol> <p>2) Email/Token Authentication</p> <p>You can create an API token from your Atlassian account:</p> <ol> <li> <p>Log in to https://id.atlassian.com/manage-profile/security/api-tokens.</p> </li> <li> <p>Click Create API token.</p> </li> <li> <p>From the dialog that appears, enter a name for your new token and click Create.</p> </li> <li> <p>Click Copy to clipboard.</p> </li> </ol> <p></p> <ol> <li>In your configuration file add the following lines:</li> </ol> <pre><code>[jira]\njira_api_token = \"YOUR_API_TOKEN\"\njira_api_email = \"YOUR_EMAIL\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#jira-data-centerserver","title":"Jira Data Center/Server \ud83d\udc8e","text":""},{"location":"core-abilities/fetching_ticket_context/#local-app-authentication-for-qodo-merge-on-premise-customers","title":"Local App Authentication (For Qodo Merge On-Premise Customers)","text":""},{"location":"core-abilities/fetching_ticket_context/#1-step-1-set-up-an-application-link-in-jira-data-centerserver","title":"1. Step 1: Set up an application link in Jira Data Center/Server","text":"<ul> <li>Go to Jira Administration &gt; Applications &gt; Application Links &gt; Click on <code>Create link</code></li> </ul> <p> * Choose <code>External application</code> and set the direction to <code>Incoming</code> and then click <code>Continue</code></p> <p> * In the following screen, enter the following details:     * Name: <code>Qodo Merge</code>     * Redirect URL: Enter your Qodo Merge URL followed  <code>https://{QODO_MERGE_ENDPOINT}/register_ticket_provider</code>     * Permission: Select <code>Read</code>     * Click <code>Save</code></p> <p> * Copy the <code>Client ID</code> and <code>Client secret</code> and set them in your <code>.secrets</code> file:</p> <p> <pre><code>[jira]\njira_app_secret = \"...\"\njira_client_id = \"...\"\n</code></pre></p>"},{"location":"core-abilities/fetching_ticket_context/#2-step-2-authenticate-with-jira-data-centerserver","title":"2. Step 2: Authenticate with Jira Data Center/Server","text":"<ul> <li>Open this URL in your browser: <code>https://{QODO_MERGE_ENDPOINT}/jira_auth</code></li> <li>Click on link</li> </ul> <ul> <li>You will be redirected to Jira Data Center/Server, click <code>Allow</code></li> <li>You will be redirected back to Qodo Merge PR Agent and you will see a success message.</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#personal-access-token-pat-authentication","title":"Personal Access Token (PAT) Authentication","text":"<p>We also support Personal Access Token (PAT) Authentication method.</p> <ol> <li>Create a Personal Access Token (PAT) in your Jira account</li> <li>In your Configuration file/Environment variables/Secrets file, add the following lines:</li> </ol> <pre><code>[jira]\njira_base_url = \"YOUR_JIRA_BASE_URL\" # e.g. https://jira.example.com\njira_api_token = \"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"core-abilities/impact_evaluation/","title":"Overview - Impact Evaluation \ud83d\udc8e","text":"<p>Demonstrating the return on investment (ROI) of AI-powered initiatives is crucial for modern organizations. To address this need, Qodo Merge has developed an AI impact measurement tools and metrics, providing advanced analytics to help businesses quantify the tangible benefits of AI adoption in their PR review process.</p>"},{"location":"core-abilities/impact_evaluation/#auto-impact-validator-real-time-tracking-of-implemented-qodo-merge-suggestions","title":"Auto Impact Validator - Real-Time Tracking of Implemented Qodo Merge Suggestions","text":""},{"location":"core-abilities/impact_evaluation/#how-it-works","title":"How It Works","text":"<p>When a user pushes a new commit to the pull request, Qodo Merge automatically compares the updated code against the previous suggestions, marking them as implemented if the changes address these recommendations, whether directly or indirectly:</p> <ol> <li>Direct Implementation: The user directly addresses the suggestion as-is in the PR, either by clicking on the \"apply code suggestion\" checkbox or by making the changes manually.</li> <li>Indirect Implementation: Qodo Merge recognizes when a suggestion's intent is fulfilled, even if the exact code changes differ from the original recommendation. It marks these suggestions as implemented, acknowledging that users may achieve the same goal through alternative solutions.</li> </ol>"},{"location":"core-abilities/impact_evaluation/#real-time-visual-feedback","title":"Real-Time Visual Feedback","text":"<p>Upon confirming that a suggestion was implemented, Qodo Merge automatically adds a \u2705 (check mark) to the relevant suggestion, enabling transparent tracking of Qodo Merge's impact analysis. Qodo Merge will also add, inside the relevant suggestions, an explanation of how the new code was impacted by each suggestion.</p> <p></p>"},{"location":"core-abilities/impact_evaluation/#dashboard-metrics","title":"Dashboard Metrics","text":"<p>The dashboard provides macro-level insights into the overall impact of Qodo Merge on the pull-request process with key productivity metrics.</p> <p>By offering clear, data-driven evidence of Qodo Merge's impact, it empowers leadership teams to make informed decisions about the tool's effectiveness and ROI.</p> <p>Here are key metrics that the dashboard tracks:</p>"},{"location":"core-abilities/impact_evaluation/#qodo-merge-impacts-per-1k-lines","title":"Qodo Merge Impacts per 1K Lines","text":"<p>Explanation: for every 1K lines of code (additions/edits), Qodo Merge had on average ~X suggestions implemented.</p> <p>Why This Metric Matters:</p> <ol> <li>Standardized and Comparable Measurement: By measuring impacts per 1K lines of code additions, you create a standardized metric that can be compared across different projects, teams, customers, and time periods. This standardization is crucial for meaningful analysis, benchmarking, and identifying where Qodo Merge is most effective.</li> <li>Accounts for PR Variability and Incentivizes Quality: This metric addresses the fact that \"Not all PRs are created equal.\" By normalizing against lines of code rather than PR count, you account for the variability in PR sizes and focus on the quality and impact of suggestions rather than just the number of PRs affected.</li> <li>Quantifies Value and ROI: The metric directly correlates with the value Qodo Merge is providing, showing how frequently it offers improvements relative to the amount of new code being written. This provides a clear, quantifiable way to demonstrate Qodo Merge's return on investment to stakeholders.</li> </ol>"},{"location":"core-abilities/impact_evaluation/#suggestion-effectiveness-across-categories","title":"Suggestion Effectiveness Across Categories","text":"<p>Explanation: This chart illustrates the distribution of implemented suggestions across different categories, enabling teams to better understand Qodo Merge's impact on various aspects of code quality and development practices.</p>"},{"location":"core-abilities/impact_evaluation/#suggestion-score-distribution","title":"Suggestion Score Distribution","text":"<p>Explanation: The distribution of the suggestion score for the implemented suggestions, ensuring that higher-scored suggestions truly represent more significant improvements.</p>"},{"location":"core-abilities/interactivity/","title":"Interactivity","text":""},{"location":"core-abilities/interactivity/#interactive-invocation","title":"Interactive invocation \ud83d\udc8e","text":"<p>TBD</p>"},{"location":"core-abilities/metadata/","title":"Local and global metadata","text":""},{"location":"core-abilities/metadata/#local-and-global-metadata-injection-with-multi-stage-analysis","title":"Local and global metadata injection with multi-stage analysis","text":"<p>1. Qodo Merge initially retrieves for each PR the following data:</p> <ul> <li>PR title and branch name</li> <li>PR original description</li> <li>Commit messages history</li> <li>PR diff patches, in hunk diff format</li> <li>The entire content of the files that were modified in the PR</li> </ul> <p>Tip: Organization-level metadata</p> <p>In addition to the inputs above, Qodo Merge can incorporate supplementary preferences provided by the user, like <code>extra_instructions</code> and <code>organization best practices</code>. This information can be used to enhance the PR analysis.</p> <p>2. By default, the first command that Qodo Merge executes is <code>describe</code>, which generates three types of outputs:</p> <ul> <li>PR Type (e.g. bug fix, feature, refactor, etc)</li> <li>PR Description - a bullet point summary of the PR</li> <li>Changes walkthrough - for each modified file, provide a one-line summary followed by a detailed bullet point list of the changes.</li> </ul> <p>These AI-generated outputs are now considered as part of the PR metadata, and can be used in subsequent commands like <code>review</code> and <code>improve</code>. This effectively enables multi-stage chain-of-thought analysis, without doing any additional API calls which will cost time and money.</p> <p>For example, when generating code suggestions for different files, Qodo Merge can inject the AI-generated \"Changes walkthrough\" file summary in the prompt:</p> <pre><code>## File: 'src/file1.py'\n### AI-generated file summary:\n- edited function `func1` that does X\n- Removed function `func2` that was not used\n- ....\n\n@@ ... @@ def func1():\n__new hunk__\n11  unchanged code line0\n12  unchanged code line1\n13 +new code line2 added\n14  unchanged code line3\n__old hunk__\n unchanged code line0\n unchanged code line1\n-old code line2 removed\n unchanged code line3\n\n@@ ... @@ def func2():\n__new hunk__\n...\n__old hunk__\n...\n</code></pre> <p>3. The entire PR files that were retrieved are also used to expand and enhance the PR context (see Dynamic Context).</p> <p>4. All the metadata described above represents several level of cumulative analysis - ranging from hunk level, to file level, to PR level, to organization level. This comprehensive approach enables Qodo Merge AI models to generate more precise and contextually relevant suggestions and feedback.</p>"},{"location":"core-abilities/self_reflection/","title":"Self-reflection","text":""},{"location":"core-abilities/self_reflection/#tldr","title":"TL;DR","text":"<p>Qodo Merge implements a self-reflection process where the AI model reflects, scores, and re-ranks its own suggestions, eliminating irrelevant or incorrect ones. This approach improves the quality and relevance of suggestions, saving users time and enhancing their experience. Configuration options allow users to set a score threshold for further filtering out suggestions.</p>"},{"location":"core-abilities/self_reflection/#introduction-efficient-review-with-hierarchical-presentation","title":"Introduction - Efficient Review with Hierarchical Presentation","text":"<p>Given that not all generated code suggestions will be relevant, it is crucial to enable users to review them in a fast and efficient way, allowing quick identification and filtering of non-applicable ones.</p> <p>To achieve this goal, Qodo Merge offers a dedicated hierarchical structure when presenting suggestions to users:</p> <ul> <li>A \"category\" section groups suggestions by their category, allowing users to quickly dismiss irrelevant suggestions.</li> <li>Each suggestion is first described by a one-line summary, which can be expanded to a full description by clicking on a collapsible.</li> <li>Upon expanding a suggestion, the user receives a more comprehensive description, and a code snippet demonstrating the recommendation.</li> </ul> <p>Fast Review</p> <p>This hierarchical structure is designed to facilitate rapid review of each suggestion, with users spending an average of ~5-10 seconds per item.</p>"},{"location":"core-abilities/self_reflection/#self-reflection-and-re-ranking","title":"Self-reflection and Re-ranking","text":"<p>The AI model is initially tasked with generating suggestions, and outputting them in order of importance. However, in practice we observe that models often struggle to simultaneously generate high-quality code suggestions and rank them well in a single pass. Furthermore, the initial set of generated suggestions sometimes contains easily identifiable errors.</p> <p>To address these issues, we implemented a \"self-reflection\" process that refines suggestion ranking and eliminates irrelevant or incorrect proposals. This process consists of the following steps:</p> <ol> <li>Presenting the generated suggestions to the model in a follow-up call.</li> <li>Instructing the model to score each suggestion on a scale of 0-10 and provide a rationale for the assigned score.</li> <li>Utilizing these scores to re-rank the suggestions and filter out incorrect ones (with a score of 0).</li> <li>Optionally, filtering out all suggestions below a user-defined score threshold.</li> </ol> <p>Note that presenting all generated suggestions simultaneously provides the model with a comprehensive context, enabling it to make more informed decisions compared to evaluating each suggestion individually.</p> <p>To conclude, the self-reflection process enables Qodo Merge to prioritize suggestions based on their importance, eliminate inaccurate or irrelevant proposals, and optionally exclude suggestions that fall below a specified threshold of significance. This results in a more refined and valuable set of suggestions for the user, saving time and improving the overall experience.</p>"},{"location":"core-abilities/self_reflection/#example-results","title":"Example Results","text":""},{"location":"core-abilities/self_reflection/#appendix-relevant-configuration-options","title":"Appendix - Relevant Configuration Options","text":"<pre><code>[pr_code_suggestions]\nsuggestions_score_threshold = 0 # Filter out suggestions with a score below this threshold (0-10)\n</code></pre>"},{"location":"core-abilities/static_code_analysis/","title":"Static code analysis","text":""},{"location":"core-abilities/static_code_analysis/#overview-static-code-analysis","title":"Overview - Static Code Analysis \ud83d\udc8e","text":"<p>By combining static code analysis with LLM capabilities, Qodo Merge can provide a comprehensive analysis of the PR code changes on a component level.</p> <p>It scans the PR code changes, finds all the code components (methods, functions, classes) that changed, and enables to interactively generate tests, docs, code suggestions and similar code search for each component.</p> <p>Language that are currently supported:</p> <p>Python, Java, C++, JavaScript, TypeScript, C#.</p>"},{"location":"core-abilities/static_code_analysis/#capabilities","title":"Capabilities","text":""},{"location":"core-abilities/static_code_analysis/#analyze-pr","title":"Analyze PR","text":"<p>The <code>analyze</code> tool enables to interactively generate tests, docs, code suggestions and similar code search for each component that changed in the PR. It can be invoked manually by commenting on any PR: <pre><code>/analyze\n</code></pre></p> <p>An example result:</p> <p></p> <p>Clicking on each checkbox will trigger the relevant tool for the selected component.</p>"},{"location":"core-abilities/static_code_analysis/#generate-tests","title":"Generate Tests","text":"<p>The <code>test</code> tool  generate tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR: <pre><code>/test component_name\n</code></pre> where 'component_name' is the name of a specific component in the PR,  Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#generate-docs-for-a-component","title":"Generate Docs for a Component","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically generate docstrings for any code components that changed in the PR. It can be invoked manually by commenting on any PR: <pre><code>/add_docs component_name\n</code></pre></p> <p>Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#generate-code-suggestions-for-a-component","title":"Generate Code Suggestions for a Component","text":"<p>The <code>improve_component</code> tool generates code suggestions for a specific code component that changed in the PR. It can be invoked manually by commenting on any PR: <pre><code>/improve_component component_name\n</code></pre></p> <p>Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#find-similar-code","title":"Find Similar Code","text":"<p>The <code>similar code</code> tool retrieves the most similar code components from inside the organization's codebase or from open-source code, including details about the license associated with each repository.</p> <p>For example:</p> <p><code>Global Search</code> for a method called <code>chat_completion</code>:</p> <p></p>"},{"location":"faq/","title":"FAQ","text":"Q: Can Qodo Merge serve as a substitute for a human reviewer? Q: I received an incorrect or irrelevant suggestion. Why? Q: How can I get more tailored suggestions? Q: Will you store my code? Are you using my code to train models? Q: Can I use my own LLM keys with Qodo Merge? Q: Can Qodo Merge review draft/offline PRs? Q: Can the 'Review effort' feedback be calibrated or customized?"},{"location":"faq/#answer1","title":"Answer:1","text":"<p>Qodo Merge is designed to assist, not replace, human reviewers.</p> <p>Reviewing PRs is a tedious and time-consuming task often seen as a \"chore\". In addition, the longer the PR \u2013 the shorter the relative feedback, since long PRs can overwhelm reviewers, both in terms of technical difficulty, and the actual review time. Qodo Merge aims to address these pain points, and to assist and empower both the PR author and reviewer.</p> <p>However, Qodo Merge has built-in safeguards to ensure the developer remains in the driver's seat. For example:</p> <ol> <li>Preserves user's original PR header</li> <li>Places user's description above the AI-generated PR description</li> <li>Won't approve PRs; approval remains reviewer's responsibility</li> <li>The code suggestions are optional, and aim to:<ul> <li>Encourage self-review and self-reflection</li> <li>Highlight potential bugs or oversights</li> <li>Enhance code quality and promote best practices</li> </ul> </li> </ol> <p>Read more about this issue in our blog</p>"},{"location":"faq/#answer2","title":"Answer:2","text":"<ul> <li>Modern AI models, like Claude 3.5 Sonnet and GPT-4, are improving rapidly but remain imperfect. Users should critically evaluate all suggestions rather than accepting them automatically.</li> <li> <p>AI errors are rare, but possible. A main value from reviewing the code suggestions lies in their high probability of catching mistakes or bugs made by the PR author. We believe it's worth spending 30-60 seconds reviewing suggestions, even if some aren't relevant, as this practice can enhance code quality and prevent bugs in production.</p> </li> <li> <p>The hierarchical structure of the suggestions is designed to help the user quickly understand them, and to decide which ones are relevant and which are not:</p> <ul> <li>Only if the <code>Category</code> header is relevant, the user should move to the summarized suggestion description.</li> <li>Only if the summarized suggestion description is relevant, the user should click on the collapsible, to read the full suggestion description with a code preview example.</li> </ul> </li> <li> <p>In addition, we recommend to use the <code>extra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.</p> </li> <li>The interactive PR chat also provides an easy way to get more tailored suggestions and feedback from the AI model.</li> </ul>"},{"location":"faq/#answer3","title":"Answer:3","text":"<p>See here for more information on how to use the <code>extra_instructions</code> and <code>best_practices</code> configuration options, to guide the model to more tailored suggestions.</p>"},{"location":"faq/#answer4","title":"Answer:4","text":"<p>No. Qodo Merge strict privacy policy ensures that your code is not stored or used for training purposes.</p> <p>For a detailed overview of our data privacy policy, please refer to this link</p>"},{"location":"faq/#answer5","title":"Answer:5","text":"<p>When you self-host the open-source version, you use your own keys.</p> <p>Qodo Merge with SaaS deployment is a hosted version of Qodo Merge, where Qodo manages the infrastructure and the keys. For enterprise customers, on-prem deployment is also available. Contact us for more information.</p>"},{"location":"faq/#answer5_1","title":"Answer:5","text":"<p>Yes. While Qodo Merge won't automatically review draft PRs, you can still get feedback by manually requesting it through online commenting.</p> <p>For active PRs, you can customize the automatic feedback settings here to match your team's workflow.</p>"},{"location":"faq/#answer5_2","title":"Answer:5","text":"<p>Yes, you can customize review effort estimates using the <code>extra_instructions</code> configuration option (see documentation).</p> <p>Example mapping:</p> <ul> <li>Effort 1: &lt; 30 minutes review time</li> <li>Effort 2: 30-60 minutes review time</li> <li>Effort 3: 60-90 minutes review time</li> <li>...</li> </ul> <p>Note: The effort levels (1-5) are primarily meant for comparative purposes, helping teams prioritize reviewing smaller PRs first. The actual review duration may vary, as the focus is on providing consistent relative effort estimates.</p>"},{"location":"finetuning_benchmark/","title":"Qodo Merge Code Fine-tuning Benchmark","text":"<p>On coding tasks, the gap between open-source models and top closed-source models such as GPT4 is significant.  In practice, open-source models are unsuitable for most real-world code tasks, and require further fine-tuning to produce acceptable results.</p> <p>Qodo Merge fine-tuning benchmark aims to benchmark open-source models on their ability to be fine-tuned for a coding task. Specifically, we chose to fine-tune open-source models on the task of analyzing a pull request, and providing useful feedback and code suggestions.</p> <p>Here are the results:  </p> <p>Model performance:</p> Model name Model size [B] Better than gpt-4 rate, after fine-tuning [%] DeepSeek 34B-instruct 34 40.7 DeepSeek 34B-base 34 38.2 Phind-34b 34 38 Granite-34B 34 37.6 Codestral-22B-v0.1 22 32.7 QWEN-1.5-32B 32 29 CodeQwen1.5-7B 7 35.4 Llama-3.1-8B-Instruct 8 35.2 Granite-8b-code-instruct 8 34.2 CodeLlama-7b-hf 7 31.8 Gemma-7B 7 27.2 DeepSeek coder-7b-instruct 7 26.8 Llama-3-8B-Instruct 8 26.8 Mistral-7B-v0.1 7 16.1 <p></p> <p>Fine-tuning impact:</p> Model name Model size [B] Fine-tuned Better than gpt-4 rate [%] DeepSeek 34B-instruct 34 yes 40.7 DeepSeek 34B-instruct 34 no 3.6"},{"location":"finetuning_benchmark/#results-analysis","title":"Results analysis","text":"<ul> <li>Fine-tuning is a must - without fine-tuning, open-source models provide poor results on most real-world code tasks, which include complicated prompt and lengthy context. We clearly see that without fine-tuning, deepseek model was 96.4% of the time inferior to GPT-4, while after fine-tuning, it is better 40.7% of the time.</li> <li>Always start from a code-dedicated model \u2014 When fine-tuning, always start from a code-dedicated model, and not from a general-usage model. The gaps in downstream results are very big.</li> <li>Don't believe the hype \u2014newer models, or models from big-tech companies (Llama3, Gemma, Mistral), are not always better for fine-tuning.</li> <li>The best large model - For large 34B code-dedicated models, the gaps when doing proper fine-tuning are small. The current top model is DeepSeek 34B-instruct</li> <li>The best small model - For small 7B code-dedicated models, the gaps when fine-tuning are much larger. CodeQWEN 1.5-7B is by far the best model for fine-tuning.</li> <li>Base vs. instruct - For the top model (deepseek), we saw small advantage when starting from the instruct version. However, we recommend testing both versions on each specific task, as the base model is generally considered more suitable for fine-tuning.</li> </ul>"},{"location":"finetuning_benchmark/#the-dataset","title":"The dataset","text":""},{"location":"finetuning_benchmark/#training-dataset","title":"Training dataset","text":"<p>Our training dataset comprises 25,000 pull requests, aggregated from permissive license repos. For each pull request, we generated responses for the three main tools of Qodo Merge: Describe, Review and Improve.</p> <p>On the raw data collected, we employed various automatic and manual cleaning techniques to ensure the outputs were of the highest quality, and suitable for instruct-tuning.</p> <p>Here are the prompts, and example outputs, used as input-output pairs to fine-tune the models:</p> Tool Prompt Example output Describe link link Review link link Improve link link"},{"location":"finetuning_benchmark/#evaluation-dataset","title":"Evaluation dataset","text":"<ul> <li>For each tool, we aggregated 200 additional examples to be used for evaluation. These examples were not used in the training dataset, and were manually selected to represent diverse real-world use-cases.</li> <li> <p>For each test example, we generated two responses: one from the fine-tuned model, and one from the best code model in the world, <code>gpt-4-turbo-2024-04-09</code>.</p> </li> <li> <p>We used a third LLM to judge which response better answers the prompt, and will likely be perceived by a human as better response. </p> </li> </ul> <p>We experimented with three model as judges: <code>gpt-4-turbo-2024-04-09</code>, <code>gpt-4o</code>, and <code>claude-3-opus-20240229</code>. All three produced similar results, with the same ranking order. This strengthens the validity of our testing protocol. The evaluation prompt can be found here</p> <p>Here is an example of a judge model feedback:</p> <pre><code>command: improve\nmodel1_score: 9,\nmodel2_score: 6,\nwhy: |\n  Response 1 is better because it provides more actionable and specific suggestions that directly\n  enhance the code's maintainability, performance, and best practices. For example, it suggests\n  using a variable for reusable widget instances and using named routes for navigation, which\n  are practical improvements. In contrast, Response 2 focuses more on general advice and less\n  actionable suggestions, such as changing variable names and adding comments, which are less\n  critical for immediate code improvement.\"\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<p>There are several ways to use self-hosted PR-Agent:</p> <ul> <li>Locally</li> <li>GitHub integration</li> <li>GitLab integration</li> <li>BitBucket integration</li> <li>Azure DevOps integration</li> </ul>"},{"location":"installation/#qodo-merge","title":"Qodo Merge \ud83d\udc8e","text":"<p>Qodo Merge, an app hosted by QodoAI for GitHub\\GitLab\\BitBucket, is also available.  With Qodo Merge, installation is as simple as adding the Qodo Merge app to your relevant repositories. See here for more details.</p>"},{"location":"installation/azure/","title":"Azure","text":""},{"location":"installation/azure/#azure-devops-pipeline","title":"Azure DevOps Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as an Azure devops pipeline. add the following file to your repository under <code>azure-pipelines.yml</code>: <pre><code># Opt out of CI triggers\ntrigger: none\n\n# Configure PR trigger\npr:\n  branches:\n    include:\n    - '*'\n  autoCancel: true\n  drafts: false\n\nstages:\n- stage: pr_agent\n  displayName: 'PR Agent Stage'\n  jobs:\n  - job: pr_agent_job\n    displayName: 'PR Agent Job'\n    pool:\n      vmImage: 'ubuntu-latest'\n    container:\n      image: codiumai/pr-agent:latest\n      options: --entrypoint \"\"\n    variables:\n      - group: pr_agent\n    steps:\n    - script: |\n        echo \"Running PR Agent action step\"\n\n        # Construct PR_URL\n        PR_URL=\"${SYSTEM_COLLECTIONURI}${SYSTEM_TEAMPROJECT}/_git/${BUILD_REPOSITORY_NAME}/pullrequest/${SYSTEM_PULLREQUEST_PULLREQUESTID}\"\n        echo \"PR_URL=$PR_URL\"\n\n        # Extract organization URL from System.CollectionUri\n        ORG_URL=$(echo \"$(System.CollectionUri)\" | sed 's/\\/$//') # Remove trailing slash if present\n        echo \"Organization URL: $ORG_URL\"\n\n        export azure_devops__org=\"$ORG_URL\"\n        export config__git_provider=\"azure\"\n\n        pr-agent --pr_url=\"$PR_URL\" describe\n        pr-agent --pr_url=\"$PR_URL\" review\n        pr-agent --pr_url=\"$PR_URL\" improve\n      env:\n        azure_devops__pat: $(azure_devops_pat)\n        openai__key: $(OPENAI_KEY)\n      displayName: 'Run Qodo Merge'\n</code></pre> This script will run Qodo Merge on every new merge request, with the <code>improve</code>, <code>review</code>, and <code>describe</code> commands. Note that you need to export the <code>azure_devops__pat</code> and <code>OPENAI_KEY</code> variables in the Azure DevOps pipeline settings (Pipelines -&gt; Library -&gt; + Variable group):</p> <p></p> <p>Make sure to give pipeline permissions to the <code>pr_agent</code> variable group.</p> <p>Note that Azure Pipelines lacks support for triggering workflows from PR comments. If you find a viable solution, please contribute it to our issue tracker</p>"},{"location":"installation/azure/#azure-devops-from-cli","title":"Azure DevOps from CLI","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"installation/azure/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To trigger from an Azure webhook, you need to manually add a webhook. Use the \"Pull request created\" type to trigger a review, or \"Pull request commented on\" to trigger any supported comment with /  comment on the relevant PR. Note that for the \"Pull request commented on\" trigger, only API v2.0 is supported. <p>For webhook security, create a sporadic username/password pair and configure the webhook username and password on both the server and Azure DevOps webhook. These will be sent as basic Auth data by the webhook with each request: <pre><code>[azure_devops_server]\nwebhook_username = \"&lt;basic auth user&gt;\"\nwebhook_password = \"&lt;basic auth password&gt;\"\n</code></pre></p> <p> Ensure that the webhook endpoint is only accessible over HTTPS to mitigate the risk of credential interception when using basic authentication.</p>"},{"location":"installation/bitbucket/","title":"Bitbucket","text":""},{"location":"installation/bitbucket/#run-as-a-bitbucket-pipeline","title":"Run as a Bitbucket Pipeline","text":"<p>You can use the Bitbucket Pipeline system to run Qodo Merge on every pull request open or update.</p> <ol> <li>Add the following file in your repository bitbucket-pipelines.yml</li> </ol> <pre><code>pipelines:\n    pull-requests:\n      '**':\n        - step:\n            name: PR Agent Review\n            image: python:3.10\n            services:\n              - docker\n            script:\n              - docker run -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=https://bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG/pull-requests/$BITBUCKET_PR_ID review\n</code></pre> <ol> <li>Add the following secure variables to your repository under Repository settings &gt; Pipelines &gt; Repository variables. OPENAI_API_KEY: <code>&lt;your key&gt;</code> BITBUCKET_BEARER_TOKEN: <code>&lt;your token&gt;</code></li> </ol> <p>You can get a Bitbucket token for your repository by following Repository Settings -&gt; Security -&gt; Access Tokens.</p> <p>Note that comments on a PR are not supported in Bitbucket Pipeline.</p>"},{"location":"installation/bitbucket/#bitbucket-server-and-data-center","title":"Bitbucket Server and Data Center","text":"<p>Login into your on-prem instance of Bitbucket with your service account username and password. Navigate to <code>Manage account</code>, <code>HTTP Access tokens</code>, <code>Create Token</code>. Generate the token and add it to .secret.toml under <code>bitbucket_server</code> section</p> <pre><code>[bitbucket_server]\nbearer_token = \"&lt;your key&gt;\"\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-cli","title":"Run it as CLI","text":"<p>Modify <code>configuration.toml</code>:</p> <pre><code>git_provider=\"bitbucket_server\"\n</code></pre> <p>and pass the Pull request URL: <pre><code>python cli.py --pr_url https://git.onpreminstanceofbitbucket.com/projects/PROJECT/repos/REPO/pull-requests/1 review\n</code></pre></p>"},{"location":"installation/bitbucket/#run-it-as-service","title":"Run it as service","text":"<p>To run Qodo Merge as webhook, build the docker image: <pre><code>docker build . -t codiumai/pr-agent:bitbucket_server_webhook --target bitbucket_server_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:bitbucket_server_webhook  # Push to your Docker repository\n</code></pre></p> <p>Navigate to <code>Projects</code> or <code>Repositories</code>, <code>Settings</code>, <code>Webhooks</code>, <code>Create Webhook</code>. Fill the name and URL, Authentication None select the Pull Request Opened checkbox to receive that event as webhook.</p> <p>The URL should end with <code>/webhook</code>, for example: https://domain.com/webhook</p>"},{"location":"installation/github/","title":"Github","text":""},{"location":"installation/github/#run-as-a-github-action","title":"Run as a GitHub Action","text":"<p>You can use our pre-built Github Action Docker image to run PR-Agent as a Github Action.</p> <p>1) Add the following file to your repository under <code>.github/workflows/pr_agent.yml</code>:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>2) Add the following secret to your repository under <code>Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret &gt; Add secret</code>:</p> <pre><code>Name = OPENAI_KEY\nSecret = &lt;your key&gt;\n</code></pre> <p>The GITHUB_TOKEN secret is automatically created by GitHub.</p> <p>3) Merge this change to your main branch. When you open your next PR, you should see a comment from <code>github-actions</code> bot with a review of your PR, and instructions on how to use the rest of the tools.</p> <p>4) You may configure Qodo Merge by adding environment variables under the env section corresponding to any configurable property in the configuration file. Some examples: <pre><code>      env:\n        # ... previous environment values\n        OPENAI.ORG: \"&lt;Your organization name under your OpenAI account&gt;\"\n        PR_REVIEWER.REQUIRE_TESTS_REVIEW: \"false\" # Disable tests review\n        PR_CODE_SUGGESTIONS.NUM_CODE_SUGGESTIONS: 6 # Increase number of code suggestions\n</code></pre> See detailed usage instructions in the USAGE GUIDE</p>"},{"location":"installation/github/#using-a-specific-release","title":"Using a specific release","text":"<p>if you want to pin your action to a specific release (v0.23 for example) for stability reasons, use: <pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent:0.23-github_action\n...\n</code></pre></p> <p>For enhanced security, you can also specify the Docker image by its digest: <pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent@sha256:14165e525678ace7d9b51cda8652c2d74abb4e1d76b57c4a6ccaeba84663cc64\n...\n</code></pre></p>"},{"location":"installation/github/#action-for-github-enterprise-server","title":"Action for GitHub enterprise server","text":"<p>To use the action with a GitHub enterprise server, add an environment variable <code>GITHUB.BASE_URL</code> with the API URL of your GitHub server.</p> <p>For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to your workflow file: <pre><code>      env:\n        # ... previous environment values\n        GITHUB.BASE_URL: \"https://github.mycompany.com/api/v3\"\n</code></pre></p>"},{"location":"installation/github/#run-as-a-github-app","title":"Run as a GitHub App","text":"<p>Allowing you to automate the review process on your private or public repositories.</p> <p>1) Create a GitHub App from the Github Developer Portal.</p> <ul> <li>Set the following permissions:<ul> <li>Pull requests: Read &amp; write</li> <li>Issue comment: Read &amp; write</li> <li>Metadata: Read-only</li> <li>Contents: Read-only</li> </ul> </li> <li>Set the following events:<ul> <li>Issue comment</li> <li>Pull request</li> <li>Push (if you need to enable triggering on PR update)</li> </ul> </li> </ul> <p>2) Generate a random secret for your app, and save it for later. For example, you can use:</p> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <p>3) Acquire the following pieces of information from your app's settings page:</p> <ul> <li>App private key (click \"Generate a private key\" and save the file)</li> <li>App ID</li> </ul> <p>4) Clone this repository:</p> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <p>5) Copy the secrets template file and fill in the following:</p> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ul> <li>Your OpenAI key.</li> <li>Copy your app's private key to the private_key field.</li> <li>Copy your app's ID to the app_id field.</li> <li>Copy your app's webhook secret to the webhook_secret field.</li> <li> <p>Set deployment_type to 'app' in configuration.toml</p> <p>The .secrets.toml file is not copied to the Docker image by default, and is only used for local development. If you want to use the .secrets.toml file in your Docker image, you can add remove it from the .dockerignore file. In most production environments, you would inject the secrets file as environment variables or as mounted volumes. For example, in order to inject a secrets file as a volume in a Kubernetes environment you can update your pod spec to include the following, assuming you have a secret named <code>pr-agent-settings</code> with a key named <code>.secrets.toml</code>: <pre><code>       volumes:\n        - name: settings-volume\n          secret:\n            secretName: pr-agent-settings\n// ...\n       containers:\n// ...\n          volumeMounts:\n            - mountPath: /app/pr_agent/settings_prod\n              name: settings-volume\n</code></pre></p> <p>Another option is to set the secrets as environment variables in your deployment environment, for example <code>OPENAI.KEY</code> and <code>GITHUB.USER_TOKEN</code>.</p> </li> </ul> <p>6) Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> <pre><code>```\ndocker build . -t codiumai/pr-agent:github_app --target github_app -f docker/Dockerfile\ndocker push codiumai/pr-agent:github_app  # Push to your Docker repository\n```\n</code></pre> <ol> <li> <p>Host the app using a server, serverless function, or container environment. Alternatively, for development and    debugging, you may use tools like smee.io to forward webhooks to your local machine.     You can check Deploy as a Lambda Function</p> </li> <li> <p>Go back to your app's settings, and set the following:</p> </li> <li> <p>Webhook URL: The URL of your app's server or the URL of the smee.io channel.</p> </li> <li> <p>Webhook secret: The secret you generated earlier.</p> </li> <li> <p>Install the app by navigating to the \"Install App\" tab and selecting your desired repositories.</p> </li> </ol> <p>Note: When running Qodo Merge from GitHub app, the default configuration file (configuration.toml) will be loaded. However, you can override the default tool parameters by uploading a local configuration file <code>.pr_agent.toml</code> For more information please check out the USAGE GUIDE</p>"},{"location":"installation/github/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITHUB.WEBHOOK_SECRET</code> --&gt; <code>GITHUB__WEBHOOK_SECRET</code></p> <ol> <li>Follow steps 1-5 from here.</li> <li>Build a docker image that can be used as a lambda function     <code>shell     docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:serverless -f docker/Dockerfile.lambda</code></li> <li>Push image to ECR     <pre><code>docker tag codiumai/pr-agent:serverless &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\n</code></pre></li> <li>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Method 5 with the function url as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/api/v1/github_webhooks</code></li> </ol>"},{"location":"installation/github/#aws-codecommit-setup","title":"AWS CodeCommit Setup","text":"<p>Not all features have been added to CodeCommit yet.  As of right now, CodeCommit has been implemented to run the Qodo Merge CLI on the command line, using AWS credentials stored in environment variables.  (More features will be added in the future.)  The following is a set of instructions to have Qodo Merge do a review of your CodeCommit pull request from the command line:</p> <ol> <li>Create an IAM user that you will use to read CodeCommit pull requests and post comments<ul> <li>Note: That user should have CLI access only, not Console access</li> </ul> </li> <li>Add IAM permissions to that user, to allow access to CodeCommit (see IAM Role example below)</li> <li>Generate an Access Key for your IAM user</li> <li>Set the Access Key and Secret using environment variables (see Access Key example below)</li> <li>Set the <code>git_provider</code> value to <code>codecommit</code> in the <code>pr_agent/settings/configuration.toml</code> settings file</li> <li>Set the <code>PYTHONPATH</code> to include your <code>pr-agent</code> project directory<ul> <li>Option A: Add <code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent</code> to your <code>.env</code> file</li> <li>Option B: Set <code>PYTHONPATH</code> and run the CLI in one command, for example:<ul> <li><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent python pr_agent/cli.py [--ARGS]</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"installation/github/#aws-codecommit-iam-role-example","title":"AWS CodeCommit IAM Role Example","text":"<p>Example IAM permissions to that user to allow access to CodeCommit:</p> <ul> <li>Note: The following is a working example of IAM permissions that has read access to the repositories and write access to allow posting comments</li> <li>Note: If you only want pr-agent to review your pull requests, you can tighten the IAM permissions further, however this IAM example will work, and allow the pr-agent to post comments to the PR</li> <li>Note: You may want to replace the <code>\"Resource\": \"*\"</code> with your list of repos, to limit access to only those repos</li> </ul> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codecommit:BatchDescribe*\",\n                \"codecommit:BatchGet*\",\n                \"codecommit:Describe*\",\n                \"codecommit:EvaluatePullRequestApprovalRules\",\n                \"codecommit:Get*\",\n                \"codecommit:List*\",\n                \"codecommit:PostComment*\",\n                \"codecommit:PutCommentReaction\",\n                \"codecommit:UpdatePullRequestDescription\",\n                \"codecommit:UpdatePullRequestTitle\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"installation/github/#aws-codecommit-access-key-and-secret","title":"AWS CodeCommit Access Key and Secret","text":"<p>Example setting the Access Key and Secret using environment variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"XXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"XXXXXXXXXXXXXXXX\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre>"},{"location":"installation/github/#aws-codecommit-cli-example","title":"AWS CodeCommit CLI Example","text":"<p>After you set up AWS CodeCommit using the instructions above, here is an example CLI run that tells pr-agent to review a given pull request. (Replace your specific PYTHONPATH and PR URL in the example)</p> <pre><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent\" python pr_agent/cli.py \\\n  --pr_url https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/MY_REPO_NAME/pull-requests/321 \\\n  review\n</code></pre>"},{"location":"installation/gitlab/","title":"Gitlab","text":""},{"location":"installation/gitlab/#run-as-a-gitlab-pipeline","title":"Run as a GitLab Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as a GitLab pipeline. This is a simple way to get started with Qodo Merge without setting up your own server.</p> <p>(1) Add the following file to your repository under <code>.gitlab-ci.yml</code>: <pre><code>stages:\n  - pr_agent\n\npr_agent_job:\n  stage: pr_agent\n  image:\n    name: codiumai/pr-agent:latest\n    entrypoint: [\"\"]\n  script:\n    - cd /app\n    - echo \"Running PR Agent action step\"\n    - export MR_URL=\"$CI_MERGE_REQUEST_PROJECT_URL/merge_requests/$CI_MERGE_REQUEST_IID\"\n    - echo \"MR_URL=$MR_URL\"\n    - export gitlab__url=$CI_SERVER_PROTOCOL://$CI_SERVER_FQDN\n    - export gitlab__PERSONAL_ACCESS_TOKEN=$GITLAB_PERSONAL_ACCESS_TOKEN\n    - export config__git_provider=\"gitlab\"\n    - export openai__key=$OPENAI_KEY\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" describe\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" review\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" improve\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n</code></pre> This script will run Qodo Merge on every new merge request. You can modify the <code>rules</code> section to run Qodo Merge on different events. You can also modify the <code>script</code> section to run different Qodo Merge commands, or with different parameters by exporting different environment variables.</p> <p>(2) Add the following masked variables to your GitLab repository (CI/CD -&gt; Variables):</p> <ul> <li> <p><code>GITLAB_PERSONAL_ACCESS_TOKEN</code>: Your GitLab personal access token.</p> </li> <li> <p><code>OPENAI_KEY</code>: Your OpenAI key.</p> </li> </ul> <p>Note that if your base branches are not protected, don't set the variables as <code>protected</code>, since the pipeline will not have access to them.</p> <p>Note: The <code>$CI_SERVER_FQDN</code> variable is available starting from GitLab version 16.10. If you're using an earlier version, this variable will not be available. However, you can combine <code>$CI_SERVER_HOST</code> and <code>$CI_SERVER_PORT</code> to achieve the same result. Please ensure you're using a compatible version or adjust your configuration.</p>"},{"location":"installation/gitlab/#run-a-gitlab-webhook-server","title":"Run a GitLab webhook server","text":"<ol> <li> <p>From the GitLab workspace or group, create an access token with \"Reporter\" role (\"Developer\" if using Pro version of the agent) and \"api\" scope.</p> </li> <li> <p>Generate a random secret for your app, and save it for later. For example, you can use:</p> </li> </ol> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Prepare variables and secrets. Skip this step if you plan on settings these as environment variables when running the agent:</li> <li> <p>In the configuration file/variables:</p> <ul> <li>Set <code>deployment_type</code> to \"gitlab\"</li> </ul> </li> <li> <p>In the secrets file/variables:</p> <ul> <li>Set your AI model key in the respective section</li> <li>In the [gitlab] section, set <code>personal_access_token</code> (with token from step 1) and <code>shared_secret</code> (with secret from step 2)</li> </ul> </li> <li> <p>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example: <pre><code>docker build . -t gitlab_pr_agent --target gitlab_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:gitlab_webhook  # Push to your Docker repository\n</code></pre></p> </li> <li> <p>Create a webhook in GitLab. Set the URL to <code>http[s]://&lt;PR_AGENT_HOSTNAME&gt;/webhook</code>, the secret token to the generated secret from step 2, and enable the triggers <code>push</code>, <code>comments</code> and <code>merge request events</code>.</p> </li> <li> <p>Test your installation by opening a merge request or commenting on a merge request using one of CodiumAI's commands. boxes</p> </li> </ol>"},{"location":"installation/locally/","title":"Locally","text":"<p>To run PR-Agent locally, you first need to acquire two keys:</p> <ol> <li>An OpenAI key from here, with access to GPT-4 (or a key for other language models, if you prefer).</li> <li>A personal access token from your Git platform (GitHub, GitLab, BitBucket) with repo scope. GitHub token, for example, can be issued from here</li> </ol>"},{"location":"installation/locally/#using-docker-image","title":"Using Docker image","text":"<p>A list of the relevant tools can be found in the tools guide.</p> <p>To invoke a tool (for example <code>review</code>), you can run PR-Agent directly from the Docker image. Here's how:</p> <ul> <li> <p>For GitHub:     <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e GITHUB.USER_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre>     If you are using GitHub enterprise server, you need to specify the custom url as variable.     For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to the command:     <pre><code>-e GITHUB.BASE_URL=https://github.mycompany.com/api/v3\n</code></pre></p> </li> <li> <p>For GitLab:     <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> <p>If you have a dedicated GitLab instance, you need to specify the custom url as variable: <pre><code>-e GITLAB.URL=&lt;your gitlab instance url&gt;\n</code></pre></p> </li> <li> <p>For BitBucket:     <pre><code>docker run --rm -it -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=&lt;pr_url&gt; review\n</code></pre></p> </li> </ul> <p>For other git providers, update <code>CONFIG.GIT_PROVIDER</code> accordingly and check the <code>pr_agent/settings/.secrets_template.toml</code> file for environment variables expected names and values.</p>"},{"location":"installation/locally/#utilizing-environment-variables","title":"Utilizing environment variables","text":"<p>It is also possible to provide or override the configuration by setting the corresponding environment variables. You can define the corresponding environment variables by following this convention: <code>&lt;TABLE&gt;__&lt;KEY&gt;=&lt;VALUE&gt;</code> or <code>&lt;TABLE&gt;.&lt;KEY&gt;=&lt;VALUE&gt;</code>. The <code>&lt;TABLE&gt;</code> refers to a table/section in a configuration file and <code>&lt;KEY&gt;=&lt;VALUE&gt;</code> refers to the key/value pair of a setting in the configuration file.</p> <p>For example, suppose you want to run <code>pr_agent</code> that connects to a self-hosted GitLab instance similar to an example above. You can define the environment variables in a plain text file named <code>.env</code> with the following content:</p> <pre><code>CONFIG__GIT_PROVIDER=\"gitlab\"\nGITLAB__URL=\"&lt;your url&gt;\"\nGITLAB__PERSONAL_ACCESS_TOKEN=\"&lt;your token&gt;\"\nOPENAI__KEY=\"&lt;your key&gt;\"\n</code></pre> <p>Then, you can run <code>pr_agent</code> using Docker with the following command:</p> <pre><code>docker run --rm -it --env-file .env codiumai/pr-agent:latest &lt;tool&gt; &lt;tool parameter&gt;\n</code></pre>"},{"location":"installation/locally/#i-get-an-error-when-running-the-docker-image-what-should-i-do","title":"I get an error when running the Docker image. What should I do?","text":"<p>If you encounter an error when running the Docker image, it is almost always due to a misconfiguration of api keys or tokens.</p> <p>Note that litellm, which is used by pr-agent, sometimes returns non-informative error messages such as <code>APIError: OpenAIException - Connection error.</code> Carefully check the api keys and tokens you provided and make sure they are correct. Adjustments may be needed depending on your llm provider.</p> <p>For example, for Azure OpenAI, additional keys are needed. Same goes for other providers, make sure to check the documentation</p>"},{"location":"installation/locally/#using-pip-package","title":"Using pip package","text":"<p>Install the package:</p> <pre><code>pip install pr-agent\n</code></pre> <p>Then run the relevant tool with the script below.  Make sure to fill in the required parameters (<code>user_token</code>, <code>openai_key</code>, <code>pr_url</code>, <code>command</code>):</p> <pre><code>from pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\ndef main():\n    # Fill in the following values\n    provider = \"github\" # github/gitlab/bitbucket/azure_devops\n    user_token = \"...\"  #  user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"      # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/review\" # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"', ...)\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"installation/locally/#run-from-source","title":"Run from source","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Navigate to the <code>/pr-agent</code> folder and install the requirements in your favorite virtual environment:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>Note: If you get an error related to Rust in the dependency installation then make sure Rust is installed and in your <code>PATH</code>, instructions: https://rustup.rs</p> <ol> <li>Copy the secrets template file and fill in your OpenAI key and your GitHub user token:</li> </ol> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\nchmod 600 pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ol> <li>Run the cli.py script:</li> </ol> <pre><code>python3 -m pr_agent.cli --pr_url &lt;pr_url&gt; review\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; ask &lt;your question&gt;\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; describe\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; improve\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; add_docs\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; generate_labels\npython3 -m pr_agent.cli --issue_url &lt;issue_url&gt; similar_issue\n...\n</code></pre> <p>[Optional] Add the pr_agent folder to your PYTHONPATH <pre><code>export PYTHONPATH=$PYTHONPATH:&lt;PATH to pr_agent folder&gt;\n</code></pre></p>"},{"location":"installation/pr_agent/","title":"PR-Agent Installation Guide","text":"<p>PR-Agent can be deployed in various environments and platforms. Choose the installation method that best suits your needs:</p>"},{"location":"installation/pr_agent/#local-installation","title":"\ud83d\udda5\ufe0f Local Installation","text":"<p>Learn how to run PR-Agent locally using:</p> <ul> <li>Docker image</li> <li>pip package</li> <li>CLI from source code</li> </ul> <p>View Local Installation Guide \u2192</p>"},{"location":"installation/pr_agent/#github-integration","title":"\ud83d\udc19 GitHub Integration","text":"<p>Set up PR-Agent with GitHub as:</p> <ul> <li>GitHub Action</li> <li>Local GitHub App</li> </ul> <p>View GitHub Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#gitlab-integration","title":"\ud83e\udd8a GitLab Integration","text":"<p>Deploy PR-Agent on GitLab as:</p> <ul> <li>GitLab pipeline job</li> <li>Local GitLab webhook server</li> </ul> <p>View GitLab Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#bitbucket-integration","title":"\ud83d\udfe6 BitBucket Integration","text":"<p>Implement PR-Agent in BitBucket as:</p> <ul> <li>BitBucket pipeline job</li> <li>Local BitBucket server</li> </ul> <p>View BitBucket Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#azure-devops-integration","title":"\ud83d\udd37  Azure DevOps Integration","text":"<p>Configure PR-Agent with Azure DevOps as:</p> <ul> <li>Azure DevOps pipeline job</li> <li>Local Azure DevOps webhook</li> </ul> <p>View Azure DevOps Integration Guide \u2192</p>"},{"location":"installation/qodo_merge/","title":"\ud83d\udc8e Qodo Merge","text":"<p>Qodo Merge is a versatile application compatible with GitHub, GitLab, and BitBucket, hosted by QodoAI. See here for more details about the benefits of using Qodo Merge.</p> <p>A complimentary two-week trial is provided to all new users. Following the trial period, user licenses (seats) are required for continued access. To purchase user licenses, please visit our pricing page. Once subscribed, users can seamlessly deploy the application across any of their code repositories.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-github","title":"Install Qodo Merge for GitHub","text":""},{"location":"installation/qodo_merge/#github-cloud","title":"GitHub Cloud","text":"<p>Qodo Merge for GitHub cloud is available for installation through the GitHub Marketplace.</p> <p></p>"},{"location":"installation/qodo_merge/#github-enterprise-server","title":"GitHub Enterprise Server","text":"<p>To use Qodo Merge application on your private GitHub Enterprise Server, you will need to contact Qodo for starting an Enterprise trial.</p>"},{"location":"installation/qodo_merge/#github-open-source-projects","title":"GitHub Open Source Projects","text":"<p>For open-source projects, Qodo Merge is available for free usage. To install Qodo Merge for your open-source repositories, use the following marketplace link.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-bitbucket","title":"Install Qodo Merge for Bitbucket","text":""},{"location":"installation/qodo_merge/#bitbucket-cloud","title":"Bitbucket Cloud","text":"<p>Qodo Merge for Bitbucket Cloud is available for installation through the following link</p> <p></p>"},{"location":"installation/qodo_merge/#bitbucket-server","title":"Bitbucket Server","text":"<p>To use Qodo Merge application on your private Bitbucket Server, you will need to contact us for starting an Enterprise trial.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-gitlab","title":"Install Qodo Merge for GitLab","text":""},{"location":"installation/qodo_merge/#gitlab-cloud","title":"GitLab Cloud","text":"<p>Since GitLab platform does not support apps, installing Qodo Merge for GitLab is a bit more involved, and requires the following steps:</p>"},{"location":"installation/qodo_merge/#step-1","title":"Step 1","text":"<p>Acquire a personal, project or group level access token. Enable the \u201capi\u201d scope in order to allow Qodo Merge to read pull requests, comment and respond to requests.</p> <p></p> <p>Store the token in a safe place, you won\u2019t be able to access it again after it was generated.</p>"},{"location":"installation/qodo_merge/#step-2","title":"Step 2","text":"<p>Generate a shared secret and link it to the access token. Browse to https://register.gitlab.pr-agent.codium.ai. Fill in your generated GitLab token and your company or personal name in the appropriate fields and click \"Submit\".</p> <p>You should see \"Success!\" displayed above the Submit button, and a shared secret will be generated. Store it in a safe place, you won\u2019t be able to access it again after it was generated.</p>"},{"location":"installation/qodo_merge/#step-3","title":"Step 3","text":"<p>Install a webhook for your repository or groups, by clicking \u201cwebhooks\u201d on the settings menu. Click the \u201cAdd new webhook\u201d button.</p> <p></p> <p>In the webhook definition form, fill in the following fields: URL: https://pro.gitlab.pr-agent.codium.ai/webhook</p> <p>Secret token: Your QodoAI key Trigger: Check the \u2018comments\u2019 and \u2018merge request events\u2019 boxes. Enable SSL verification: Check the box.</p> <p></p>"},{"location":"installation/qodo_merge/#step-4","title":"Step 4","text":"<p>You\u2019re all set!</p> <p>Open a new merge request or add a MR comment with one of Qodo Merge\u2019s commands such as /review, /describe or /improve.</p>"},{"location":"installation/qodo_merge/#gitlab-server","title":"GitLab Server","text":"<p>For a trial period of two weeks on your private GitLab Server, the same installation steps as for GitLab Cloud apply. After the trial period, you will need to contact Qodo for moving to an Enterprise account.</p>"},{"location":"overview/data_privacy/","title":"Data Privacy","text":""},{"location":"overview/data_privacy/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<ul> <li>If you self-host PR-Agent with your OpenAI (or other LLM provider) API key, it is between you and the provider. We don't send your code data to Qodo servers.</li> </ul>"},{"location":"overview/data_privacy/#qodo-merge","title":"Qodo Merge \ud83d\udc8e","text":"<ul> <li> <p>When using Qodo Merge\ud83d\udc8e, hosted by Qodo, we will not store any of your data, nor will we use it for training. You will also benefit from an OpenAI account with zero data retention.</p> </li> <li> <p>For certain clients, Qodo Merge will use Qodo\u2019s proprietary models. If this is the case, you will be notified.</p> </li> <li> <p>No passive collection of Code and Pull Requests\u2019 data \u2014 Qodo Merge will be active only when you invoke it, and it will then extract and analyze only data relevant to the executed command and queried pull request.</p> </li> </ul>"},{"location":"overview/data_privacy/#qodo-merge-chrome-extension","title":"Qodo Merge Chrome extension","text":"<ul> <li>The Qodo Merge Chrome extension will not send your code to any external servers.</li> </ul>"},{"location":"overview/pr_agent_pro/","title":"\ud83d\udc8e Qodo Merge","text":""},{"location":"overview/pr_agent_pro/#overview","title":"Overview","text":"<p>Qodo Merge is a paid, hosted version of open-source PR-Agent. A complimentary two-week trial is offered, followed by a monthly subscription fee. Qodo Merge is designed for companies and teams that require additional features and capabilities. It provides the following benefits:</p> <ol> <li> <p>Fully managed - We take care of everything for you - hosting, models, regular updates, and more. Installation is as simple as signing up and adding the Qodo Merge app to your GitHub\\GitLab\\BitBucket repo.</p> </li> <li> <p>Improved privacy - No data will be stored or used to train models. Qodo Merge will employ zero data retention, and will use an OpenAI and Claude accounts with zero data retention.</p> </li> <li> <p>Improved support - Qodo Merge users will receive priority support, and will be able to request new features and capabilities.</p> </li> <li> <p>Supporting self-hosted git servers - Qodo Merge can be installed on GitHub Enterprise Server, GitLab, and BitBucket. For more information, see the installation guide.</p> </li> <li> <p>PR Chat - Qodo Merge allows you to engage in private chat about your pull requests on private repositories.</p> </li> </ol>"},{"location":"overview/pr_agent_pro/#additional-features","title":"Additional features","text":"<p>Here are some of the additional features and capabilities that Qodo Merge offers:</p> Feature Description Model selection Choose the model that best fits your needs, among top models like <code>GPT4</code> and <code>Claude-Sonnet-3.5</code> Global and wiki configuration Control configurations for many repositories from a single location; Edit configuration of a single repo without committing code Apply suggestions Generate committable code from the relevant suggestions interactively by clicking on a checkbox Suggestions impact Automatically mark suggestions that were implemented by the user (either directly in GitHub, or indirectly in the IDE) to enable tracking of the impact of the suggestions CI feedback Automatically analyze failed CI checks on GitHub and provide actionable feedback in the PR conversation, helping to resolve issues quickly Advanced usage statistics Qodo Merge offers detailed statistics at user, repository, and company levels, including metrics about Qodo Merge usage, and also general statistics and insights Incorporating companies' best practices Use the companies' best practices as reference to increase the effectiveness and the relevance of the code suggestions Interactive triggering Interactively apply different tools via the <code>analyze</code> command Custom labels Define custom labels for Qodo Merge to assign to the PR"},{"location":"overview/pr_agent_pro/#additional-tools","title":"Additional tools","text":"<p>Here are additional tools that are available only for Qodo Merge users:</p> Feature Description Custom Prompt Suggestions Generate code suggestions based on custom prompts from the user Analyze PR components Identify the components that changed in the PR, and enable to interactively apply different tools to them Tests Generate tests for code components that changed in the PR PR documentation Generate docstring for code components that changed in the PR Improve Component Generate code suggestions for code components that changed in the PR Similar code search Search for similar code in the repository, organization, or entire GitHub Code implementation Generates implementation code from review suggestions"},{"location":"overview/pr_agent_pro/#supported-languages","title":"Supported languages","text":"<p>Qodo Merge leverages the world's leading code models - Claude 3.5 Sonnet and GPT-4. As a result, its primary tools such as <code>describe</code>, <code>review</code>, and <code>improve</code>, as well as the PR-chat feature, support virtually all programming languages.</p> <p>For specialized commands that require static code analysis, Qodo Merge offers support for specific languages. For more details about features that require static code analysis, please refer to the documentation.</p>"},{"location":"tools/","title":"Tools","text":"<p>Here is a list of Qodo Merge tools, each with a dedicated page that explains how to use it:</p> Tool Description PR Description (<code>/describe</code>) Automatically generating PR description - title, type, summary, code walkthrough and labels PR Review (<code>/review</code>) Adjustable feedback about the PR, possible issues, security concerns, review effort and more Code Suggestions (<code>/improve</code>) Code suggestions for improving the PR Question Answering (<code>/ask ...</code>) Answering free-text questions about the PR, or on specific code lines Update Changelog (<code>/update_changelog</code>) Automatically updating the CHANGELOG.md file with the PR changes Find Similar Issue (<code>/similar_issue</code>) Automatically retrieves and presents similar issues Help (<code>/help</code>) Provides a list of all the available tools. Also enables to trigger them interactively (\ud83d\udc8e) \ud83d\udc8e Add Documentation (<code>/add_docs</code>) Generates documentation to methods/functions/classes that changed in the PR \ud83d\udc8e Generate Custom Labels (<code>/generate_labels</code>) Generates custom labels for the PR, based on specific guidelines defined by the user \ud83d\udc8e Analyze (<code>/analyze</code>) Identify code components that changed in the PR, and enables to interactively generate tests, docs, and code suggestions for each component \ud83d\udc8e Test (<code>/test</code>) generate tests for a selected component, based on the PR code changes \ud83d\udc8e Custom Prompt (<code>/custom_prompt</code>) Automatically generates custom suggestions for improving the PR code, based on specific guidelines defined by the user \ud83d\udc8e Generate Tests (<code>/test component_name</code>) Automatically generates unit tests for a selected component, based on the PR code changes \ud83d\udc8e Improve Component (<code>/improve_component component_name</code>) Generates code suggestions for a specific code component that changed in the PR \ud83d\udc8e CI Feedback (<code>/checks ci_job</code>) Automatically generates feedback and analysis for a failed CI job \ud83d\udc8e Implement (<code>/implement</code>) Generates implementation code from review suggestions Note that the tools marked with \ud83d\udc8e are available only for Qodo Merge users."},{"location":"tools/analyze/","title":"\ud83d\udc8e Analyze","text":""},{"location":"tools/analyze/#overview","title":"Overview","text":"<p>The <code>analyze</code> tool combines advanced static code analysis with LLM capabilities to provide a comprehensive analysis of the PR code changes.</p> <p>The tool scans the PR code changes, finds the code components (methods, functions, classes) that changed, and enables to interactively generate tests, docs, code suggestions and similar code search for each component.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/analyze\n</code></pre></p>"},{"location":"tools/analyze/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p>Language that are currently supported:</p> <p>Python, Java, C++, JavaScript, TypeScript, C#.</p>"},{"location":"tools/ask/","title":"Ask","text":""},{"location":"tools/ask/#overview","title":"Overview","text":"<p>The <code>ask</code> tool answers questions about the PR, based on the PR code changes. Make sure to be specific and clear in your questions. It can be invoked manually by commenting on any PR: <pre><code>/ask \"...\"\n</code></pre></p>"},{"location":"tools/ask/#example-usage","title":"Example usage","text":""},{"location":"tools/ask/#ask-lines","title":"Ask lines","text":"<p>You can run <code>/ask</code> on specific lines of code in the PR from the PR's diff view. The tool will answer questions based on the code changes in the selected lines. - Click on the '+' sign next to the line number to select the line. - To select multiple lines, click on the '+' sign of the first line and then hold and drag to select the rest of the lines. - write <code>/ask \"...\"</code> in the comment box and press <code>Add single comment</code> button.</p> <p></p> <p>Note that the tool does not have \"memory\" of previous questions, and answers each question independently.</p>"},{"location":"tools/ask/#ask-on-images","title":"Ask on images","text":"<p>You can also ask questions about images that appear in the comment, where the entire PR code will be used as context.  The basic syntax is: <pre><code>/ask \"...\"\n\n[Image](https://real_link_to_image)\n</code></pre> where <code>https://real_link_to_image</code> is the direct link to the image.</p> <p>Note that GitHub has a built-in mechanism of pasting images in comments. However, pasted image does not provide a direct link. To get a direct link to an image, we recommend using the following scheme:</p> <p>1. First, post a comment that contains only the image:</p> <p></p> <p>2. Quote reply to that comment:</p> <p></p> <p>3. In the screen opened, type the question below the image:</p> <p> </p> <p>4. Post the comment, and receive the answer:</p> <p></p> <p>See a full video tutorial here</p>"},{"location":"tools/ci_feedback/","title":"\ud83d\udc8e CI Feedback","text":""},{"location":"tools/ci_feedback/#overview","title":"Overview","text":"<p>The CI feedback tool (<code>/checks)</code> automatically triggers when a PR has a failed check. The tool analyzes the failed checks and provides several feedbacks:</p> <ul> <li>Failed stage</li> <li>Failed test name</li> <li>Failure summary</li> <li>Relevant error logs</li> </ul>"},{"location":"tools/ci_feedback/#example-usage","title":"Example usage","text":"<p>\u2192 </p> <p>In addition to being automatically triggered, the tool can also be invoked manually by commenting on a PR: <pre><code>/checks \"https://github.com/{repo_name}/actions/runs/{run_number}/job/{job_number}\"\n</code></pre> where <code>{repo_name}</code> is the name of the repository, <code>{run_number}</code> is the run number of the failed check, and <code>{job_number}</code> is the job number of the failed check.</p>"},{"location":"tools/ci_feedback/#disabling-the-tool-from-running-automatically","title":"Disabling the tool from running automatically","text":"<p>If you wish to disable the tool from running automatically, you can do so by adding the following configuration to the configuration file: <pre><code>[checks]\nenable_auto_checks_feedback = false\n</code></pre></p>"},{"location":"tools/ci_feedback/#configuration-options","title":"Configuration options","text":"<ul> <li><code>enable_auto_checks_feedback</code> - if set to true, the tool will automatically provide feedback when a check is failed. Default is true.</li> <li><code>excluded_checks_list</code> - a list of checks to exclude from the feedback, for example: [\"check1\", \"check2\"]. Default is an empty list.</li> <li><code>persistent_comment</code> - if set to true, the tool will overwrite a previous checks comment with the new feedback. Default is true.</li> <li><code>enable_help_text=true</code> - if set to true, the tool will provide a help message when a user comments \"/checks\" on a PR. Default is true.</li> <li><code>final_update_message</code> - if <code>persistent_comment</code> is true and updating a previous checks message, the tool will also create a new message: \"Persistent checks updated to latest commit\". Default is true.</li> </ul>"},{"location":"tools/custom_labels/","title":"\ud83d\udc8e Custom Labels","text":""},{"location":"tools/custom_labels/#overview","title":"Overview","text":"<p>The <code>generate_labels</code> tool scans the PR code changes, and given a list of labels and their descriptions, it automatically suggests labels that match the PR code changes.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/generate_labels\n</code></pre></p>"},{"location":"tools/custom_labels/#example-usage","title":"Example usage","text":"<p>If we wish to add detect changes to SQL queries in a given PR, we can add the following custom label along with its description:</p> <p></p> <p>When running the <code>generate_labels</code> tool on a PR that includes changes in SQL queries, it will automatically suggest the custom label:</p> <p></p> <p>Note that in addition to the dedicated tool <code>generate_labels</code>, the custom labels will also be used by the <code>describe</code> tool.</p>"},{"location":"tools/custom_labels/#how-to-enable-custom-labels","title":"How to enable custom labels","text":"<p>There are 3 ways to enable custom labels:</p>"},{"location":"tools/custom_labels/#1-cli-local-configuration-file","title":"1. CLI (local configuration file)","text":"<p>When working from CLI, you need to apply the configuration changes to the custom_labels file:</p>"},{"location":"tools/custom_labels/#2-repo-configuration-file","title":"2. Repo configuration file","text":"<p>To enable custom labels, you need to apply the configuration changes to the local <code>.pr_agent.toml</code> file in your repository.</p>"},{"location":"tools/custom_labels/#3-handle-custom-labels-from-the-repos-labels-page","title":"3. Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>This feature is available only in Qodo Merge</p> <ul> <li>GitHub : <code>https://github.com/{owner}/{repo}/labels</code>, or click on the \"Labels\" tab in the issues or PRs page.</li> <li>GitLab : <code>https://gitlab.com/{owner}/{repo}/-/labels</code>, or click on \"Manage\" -&gt; \"Labels\" on the left menu.</li> </ul> <p>b. Add/edit the custom labels. It should be formatted as follows: * Label name: The name of the custom label. * Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>. The description should be comprehensive and detailed, indicating when to add the desired label.</p> <p></p> <p>c. Now the custom labels will be included in the <code>generate_labels</code> tool.</p> <p>This feature is supported in GitHub and GitLab.</p>"},{"location":"tools/custom_labels/#configuration-options","title":"Configuration options","text":"<ul> <li>Change <code>enable_custom_labels</code> to True: This will turn off the default labels and enable the custom labels provided in the custom_labels.toml file.</li> <li>Add the custom labels. It should be formatted as follows:</li> </ul> <pre><code>[config]\nenable_custom_labels=true\n\n[custom_labels.\"Custom Label Name\"]\ndescription = \"Description of when AI should suggest this label\"\n\n[custom_labels.\"Custom Label 2\"]\ndescription = \"Description of when AI should suggest this label 2\"\n</code></pre>"},{"location":"tools/custom_prompt/","title":"\ud83d\udc8e Custom Prompt","text":""},{"location":"tools/custom_prompt/#overview","title":"Overview","text":"<p>The <code>custom_prompt</code> tool scans the PR code changes, and automatically generates suggestions for improving the PR code. It shares similarities with the <code>improve</code> tool, but with one main difference: the <code>custom_prompt</code> tool will only propose suggestions that follow specific guidelines defined by the prompt in: <code>pr_custom_prompt.prompt</code> configuration.</p> <p>The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on a PR.</p> <p>When commenting, use the following template:</p> <pre><code>/custom_prompt --pr_custom_prompt.prompt=\"\nThe code suggestions should focus only on the following:\n- ...\n- ...\n\n\"\n</code></pre> <p>With a configuration file, use the following template:</p> <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe suggestions should focus only on the following:\n-...\n-...\n\n\"\"\"\n</code></pre> <p>Remember - with this tool, you are the prompter. Be specific, clear, and concise in the instructions. Specify relevant aspects that you want the model to focus on. \\ You might benefit from several trial-and-error iterations, until you get the correct prompt for your use case.</p>"},{"location":"tools/custom_prompt/#example-usage","title":"Example usage","text":"<p>Here is an example of a possible prompt, defined in the configuration file: <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe code suggestions should focus only on the following:\n- look for edge cases when implementing a new function\n- make sure every variable has a meaningful name\n- make sure the code is efficient\n\"\"\"\n</code></pre></p> <p>(The instructions above are just an example. We want to emphasize that the prompt should be specific and clear, and be tailored to the needs of your project)</p> <p>Results obtained with the prompt above:</p> <p></p>"},{"location":"tools/custom_prompt/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>prompt</code>: the prompt for the tool. It should be a multi-line string.</p> </li> <li> <p><code>num_code_suggestions_per_chunk</code>: number of code suggestions provided by the 'custom_prompt' tool, per chunk. Default is 4.</p> </li> <li> <p><code>enable_help_text</code>: if set to true, the tool will display a help text in the comment. Default is true.</p> </li> </ul>"},{"location":"tools/describe/","title":"Describe","text":""},{"location":"tools/describe/#overview","title":"Overview","text":"<p>The <code>describe</code> tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels.</p> <p>The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/describe\n</code></pre></p>"},{"location":"tools/describe/#example-usage","title":"Example usage","text":""},{"location":"tools/describe/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/describe</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a description for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command: <pre><code>/describe --pr_description.some_config1=... --pr_description.some_config2=...\n</code></pre></p>"},{"location":"tools/describe/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>describe</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    ...\n]\n\n[pr_description]\npublish_labels = true\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_description]</code> section contains the configurations for the <code>describe</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/describe/#configuration-options","title":"Configuration options","text":"<p>Possible configurations</p> publish_labels If set to true, the tool will publish labels to the PR. Default is false. publish_description_as_comment If set to true, the tool will publish the description as a comment to the PR. If false, it will overwrite the original description. Default is false. publish_description_as_comment_persistent If set to true and `publish_description_as_comment` is true, the tool will publish the description as a persistent comment to the PR. Default is true. add_original_user_description If set to true, the tool will add the original user description to the generated description. Default is true. generate_ai_title If set to true, the tool will also generate an AI title for the PR. Default is false. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\" enable_pr_type If set to false, it will not show the `PR type` as a text value in the description content. Default is true. final_update_message If set to true, it will add a comment message [`PR Description updated to latest commit...`](https://github.com/Codium-ai/pr-agent/pull/499#issuecomment-1837412176) after finishing calling `/describe`. Default is false. enable_semantic_files_types If set to true, \"Changes walkthrough\" section will be generated. Default is true. collapsible_file_list If set to true, the file list in the \"Changes walkthrough\" section will be collapsible. If set to \"adaptive\", the file list will be collapsible only if there are more than 8 files. Default is \"adaptive\". enable_large_pr_handling Pro feature. If set to true, in case of a large PR the tool will make several calls to the AI and combine them to be able to cover more files. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is false."},{"location":"tools/describe/#inline-file-summary","title":"Inline file summary \ud83d\udc8e","text":"<p>This feature enables you to copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, so you can quickly understand the changes in each file while reviewing the code changes (diff view).</p> <p>To copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, you can click on the checkbox that appears PR Description status message below the main PR Description:</p> <p></p> <p>If you prefer to have the file summaries appear in the \"Files changed\" tab on every PR, change the <code>pr_description.inline_file_summary</code> parameter in the configuration file, possible values are:</p> <ul> <li><code>'table'</code>: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab.</li> </ul> <p></p> <ul> <li><code>true</code>: A collapsible file comment with changes title and a changes summary for each file in the PR.</li> </ul> <p></p> <ul> <li><code>false</code> (<code>default</code>): File changes walkthrough will be added only to the \"Conversation\" tab.</li> </ul> <p>Note: that this feature is currently available only for GitHub.</p>"},{"location":"tools/describe/#markers-template","title":"Markers template","text":"<p>To enable markers, set <code>pr_description.use_description_markers=true</code>. Markers enable to easily integrate user's content and auto-generated content, with a template-like mechanism.</p> <p>For example, if the PR original description was: <pre><code>User content...\n\n## PR Type:\npr_agent:type\n\n## PR Description:\npr_agent:summary\n\n## PR Walkthrough:\npr_agent:walkthrough\n</code></pre> The marker <code>pr_agent:type</code> will be replaced with the PR type, <code>pr_agent:summary</code> will be replaced with the PR summary, and <code>pr_agent:walkthrough</code> will be replaced with the PR walkthrough.</p> <p></p> <p>becomes</p> <p></p> <p>Configuration params:</p> <ul> <li><code>use_description_markers</code>: if set to true, the tool will use markers template. It replaces every marker of the form <code>pr_agent:marker_name</code> with the relevant content. Default is false.</li> <li><code>include_generated_by_header</code>: if set to true, the tool will add a dedicated header: 'Generated by PR Agent at ...' to any automatic content. Default is true.</li> </ul>"},{"location":"tools/describe/#custom-labels","title":"Custom labels","text":"<p>The default labels of the describe tool are quite generic, since they are meant to be used in any repo: [<code>Bug fix</code>, <code>Tests</code>, <code>Enhancement</code>, <code>Documentation</code>, <code>Other</code>].</p> <p>You can define custom labels that are relevant for your repo and use cases. Custom labels can be defined in a configuration file, or directly in the repo's labels page.</p> <p>Make sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it. Each label description should be a conditional statement, that indicates if to add the label to the PR or not, according to the PR content.</p>"},{"location":"tools/describe/#handle-custom-labels-from-a-configuration-file","title":"Handle custom labels from a configuration file","text":"<p>Example for a custom labels configuration setup in a configuration file: <pre><code>[config]\nenable_custom_labels=true\n\n\n[custom_labels.\"sql_changes\"]\ndescription = \"Use when a PR contains changes to SQL queries\"\n\n[custom_labels.\"test\"]\ndescription = \"use when a PR primarily contains new tests\"\n\n...\n</code></pre></p>"},{"location":"tools/describe/#handle-custom-labels-from-the-repos-labels-page","title":"Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>You can also control the custom labels that will be suggested by the <code>describe</code> tool from the repo's labels page:</p> <ul> <li>GitHub : go to <code>https://github.com/{owner}/{repo}/labels</code> (or click on the \"Labels\" tab in the issues or PRs page)</li> <li>GitLab : go to <code>https://gitlab.com/{owner}/{repo}/-/labels</code> (or click on \"Manage\" -&gt; \"Labels\" on the left menu)</li> </ul> <p>Now add/edit the custom labels. they should be formatted as follows:</p> <ul> <li>Label name: The name of the custom label.</li> <li>Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>.</li> </ul> <p>Examples for custom labels:</p> <ul> <li><code>Main topic:performance</code> -  pr_agent:The main topic of this PR is performance</li> <li><code>New endpoint</code> -  pr_agent:A new endpoint was added in this PR</li> <li><code>SQL query</code> -  pr_agent:A new SQL query was added in this PR</li> <li><code>Dockerfile changes</code> - pr_agent:The PR contains changes in the Dockerfile</li> <li>...</li> </ul> <p>The description should be comprehensive and detailed, indicating when to add the desired label. For example: </p>"},{"location":"tools/describe/#usage-tips","title":"Usage Tips","text":"<p>Automation</p> <ul> <li>When you first install Qodo Merge app, the default mode for the describe tool is: <pre><code>pr_commands = [\"/describe\", ...]\n</code></pre> meaning the <code>describe</code> tool will run automatically on every PR, with the default configurations.</li> </ul> <ul> <li> <p>Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:    <pre><code>pr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n</code></pre>    the tool will replace every marker of the form <code>pr_agent:marker_name</code> in the PR description with the relevant content, where <code>marker_name</code> is one of the following:          * <code>type</code>: the PR type.          * <code>summary</code>: the PR summary.          * <code>walkthrough</code>: the PR walkthrough.</p> </li> <li> <p>Note that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.</p> </li> </ul>"},{"location":"tools/documentation/","title":"\ud83d\udc8e Documentation","text":""},{"location":"tools/documentation/#overview","title":"Overview","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically suggests documentation for any code components that changed in the PR (functions, classes, etc.).</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/add_docs\n</code></pre></p>"},{"location":"tools/documentation/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/add_docs</code> on any PR:</p> <p></p> <p>The tool will generate documentation for all the components that changed in the PR:</p> <p></p> <p></p> <p>You can state a name of a specific component in the PR to get documentation only for that component: <pre><code>/add_docs component_name\n</code></pre></p>"},{"location":"tools/documentation/#configuration-options","title":"Configuration options","text":"<ul> <li><code>docs_style</code>: The exact style of the documentation (for python docstring). you can choose between: <code>google</code>, <code>numpy</code>, <code>sphinx</code>, <code>restructuredtext</code>, <code>plain</code>. Default is <code>sphinx</code>.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> </ul> <p>Notes</p> <ul> <li>The following languages are currently supported: Python, Java, C++, JavaScript, TypeScript, C#.</li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/help/","title":"Help","text":""},{"location":"tools/help/#overview","title":"Overview","text":"<p>The <code>help</code> tool provides a list of all the available tools and their descriptions. For Qodo Merge users, it also enables to trigger each tool by checking the relevant box.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/help\n</code></pre></p>"},{"location":"tools/help/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p>\u2192</p> <p></p>"},{"location":"tools/implement/","title":"\ud83d\udc8e Implement","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p>"},{"location":"tools/implement/#overview","title":"Overview","text":"<p>The <code>implement</code> tool converts human code review discussions and feedback into ready-to-commit code changes. It leverages LLM technology to transform PR comments and review suggestions into concrete implementation code, helping developers quickly turn feedback into working solutions.</p>"},{"location":"tools/implement/#usage-scenarios","title":"Usage Scenarios","text":""},{"location":"tools/implement/#for-reviewers","title":"For Reviewers","text":"<p>Reviewers can request code changes by:</p> <ol> <li>Selecting the code block to be modified.</li> <li>Adding a comment with the syntax:  <pre><code>/implement &lt;code-change-description&gt;\n</code></pre></li> </ol> <p></p>"},{"location":"tools/implement/#for-pr-authors","title":"For PR Authors","text":"<p>PR authors can implement suggested changes by replying to a review comment using either:  1. Add specific implementation details as described above <pre><code>/implement &lt;code-change-description&gt;\n</code></pre> 2. Use the original review comment as instructions <pre><code>/implement\n</code></pre></p> <p></p>"},{"location":"tools/implement/#for-referencing-comments","title":"For Referencing Comments","text":"<p>You can reference and implement changes from any comment by: <pre><code>/implement &lt;link-to-review-comment&gt;\n</code></pre></p> <p></p> <p>Note that the implementation will occur within the review discussion thread.</p> <p>Configuration options</p> <ul> <li>Use <code>/implement</code> to implement code change within and based on the review discussion.</li> <li>Use <code>/implement &lt;code-change-description&gt;</code> inside a review discussion to implement specific instructions.</li> <li>Use <code>/implement &lt;link-to-review-comment&gt;</code> to indirectly call the tool from any comment.</li> </ul>"},{"location":"tools/improve/","title":"Improve","text":""},{"location":"tools/improve/#overview","title":"Overview","text":"<p>The <code>improve</code> tool scans the PR code changes, and automatically generates meaningful suggestions for improving the PR code. The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/improve\n</code></pre></p> <p></p> <p></p> <p>The following features are available only for Qodo Merge \ud83d\udc8e users:</p> <ul> <li>The <code>Apply this suggestion</code> checkbox, which interactively converts a suggestion into a committable code comment</li> <li>The <code>More</code> checkbox to generate additional suggestions</li> </ul>"},{"location":"tools/improve/#example-usage","title":"Example usage","text":""},{"location":"tools/improve/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/improve</code> on any PR. The code suggestions by default are presented as a single comment:</p> <p>To edit configurations related to the improve tool, use the following template: <pre><code>/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n</code></pre></p> <p>For example, you can choose to present all the suggestions as commitable code comments, by running the following command: <pre><code>/improve --pr_code_suggestions.commitable_code_suggestions=true\n</code></pre></p> <p></p> <p>As can be seen, a single table comment has a significantly smaller PR footprint. We recommend this mode for most cases. Also note that collapsible are not supported in Bitbucket. Hence, the suggestions can only be presented in Bitbucket as code comments.</p>"},{"location":"tools/improve/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>improve</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/improve\",\n    ...\n]\n\n[pr_code_suggestions]\nnum_code_suggestions_per_chunk = ...\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_code_suggestions]</code> section contains the configurations for the <code>improve</code> tool you want to edit (if any)</li> </ul>"},{"location":"tools/improve/#assessing-impact","title":"Assessing Impact","text":"<p><code>\ud83d\udc8e feature</code></p> <p>Qodo Merge tracks two types of implementations for tracking implemented suggestions:</p> <ul> <li>Direct implementation - when the user directly applies the suggestion by clicking the <code>Apply</code> checkbox.</li> <li>Indirect implementation - when the user implements the suggestion in their IDE environment. In this case, Qodo Merge will utilize, after each commit, a dedicated logic to identify if a suggestion was implemented, and will mark it as implemented.</li> </ul> <p></p> <p>In post-process, Qodo Merge counts the number of suggestions that were implemented, and provides general statistics and insights about the suggestions' impact on the PR process.</p> <p></p> <p></p>"},{"location":"tools/improve/#suggestion-tracking","title":"Suggestion tracking","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab</code></p> <p>Qodo Merge employs a novel detection system to automatically identify AI code suggestions that PR authors have accepted and implemented.</p> <p>Accepted suggestions are also automatically documented in a dedicated wiki page called <code>.pr_agent_accepted_suggestions</code>, allowing users to track historical changes, assess the tool's effectiveness, and learn from previously implemented recommendations in the repository. An example result:</p> <p></p> <p>This dedicated wiki page will also serve as a foundation for future AI model improvements, allowing it to learn from historically implemented suggestions and generate more targeted, contextually relevant recommendations.</p> <p>This feature is controlled by a boolean configuration parameter: <code>pr_code_suggestions.wiki_page_accepted_suggestions</code> (default is true).</p> <p>Wiki must be enabled</p> <p>While the aggregation process is automatic, GitHub repositories require a one-time manual wiki setup.</p> <p>To initialize the wiki: navigate to <code>Wiki</code>, select <code>Create the first page</code>, then click <code>Save page</code>.</p> <p></p> <p>Once a wiki repo is created, the tool will automatically use this wiki for tracking suggestions.</p> <p>Why a wiki page?</p> <p>Your code belongs to you, and we respect your privacy. Hence, we won't store any code suggestions in an external database.</p> <p>Instead, we leverage a dedicated private page, within your repository wiki, to track suggestions. This approach offers convenient secure suggestion tracking while avoiding pull requests or any noise to the main repository.</p>"},{"location":"tools/improve/#extra-instructions-and-best-practices","title":"<code>Extra instructions</code> and <code>best practices</code>","text":"<p>The <code>improve</code> tool can be further customized by providing additional instructions and best practices to the AI model.</p>"},{"location":"tools/improve/#extra-instructions","title":"Extra instructions","text":"<p>You can use the <code>extra_instructions</code> configuration option to give the AI model additional instructions for the <code>improve</code> tool. Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter.</p> <p>Examples for possible instructions: <pre><code>[pr_code_suggestions]\nextra_instructions=\"\"\"\\\n(1) Answer in japanese\n(2) Don't suggest to add try-except block\n(3) Ignore changes in toml files\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points or numbers to make the instructions more readable.</p>"},{"location":"tools/improve/#best-practices","title":"Best practices","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>Another option to give additional guidance to the AI model is by creating a <code>best_practices.md</code> file, either in your repository's root directory or as a wiki page (we recommend the wiki page, as editing and maintaining it over time is easier). This page can contain a list of best practices, coding standards, and guidelines that are specific to your repo/organization.</p> <p>The AI model will use this wiki page as a reference, and in case the PR code violates any of the guidelines, it will create additional suggestions, with a dedicated label: <code>Organization best practice</code>.</p> <p>Example for a python <code>best_practices.md</code> content: <pre><code>## Project best practices\n- Make sure that I/O operations are encapsulated in a try-except block\n- Use the `logging` module for logging instead of `print` statements\n- Use `is` and `is not` to compare with `None`\n- Use `if __name__ == '__main__':` to run the code only when the script is executed\n- Use `with` statement to open files\n...\n</code></pre></p> <p>Tips for writing an effective <code>best_practices.md</code> file:</p> <ul> <li>Write clearly and concisely</li> <li>Include brief code examples when helpful</li> <li>Focus on project-specific guidelines, that will result in relevant suggestions you actually want to get</li> <li>Keep the file relatively short, under 800 lines, since:<ul> <li>AI models may not process effectively very long documents</li> <li>Long files tend to contain generic guidelines already known to AI</li> </ul> </li> </ul>"},{"location":"tools/improve/#local-and-global-best-practices","title":"Local and global best practices","text":"<p>By default, Qodo Merge will look for a local <code>best_practices.md</code> wiki file in the root of the relevant local repo.</p> <p>If you want to enable also a global <code>best_practices.md</code> wiki file, set first in the global configuration file:</p> <pre><code>[best_practices]\nenable_global_best_practices = true\n</code></pre> <p>Then, create a <code>best_practices.md</code> wiki file in the root of global configuration repository,  <code>pr-agent-settings</code>.</p>"},{"location":"tools/improve/#best-practices-for-multiple-languages","title":"Best practices for multiple languages","text":"<p>For a git organization working with multiple programming languages, you can maintain a centralized global <code>best_practices.md</code> file containing language-specific guidelines.  When reviewing pull requests, Qodo Merge automatically identifies the programming language and applies the relevant best practices from this file.</p> <p>To do this, structure your <code>best_practices.md</code> file using the following format:</p> <pre><code># [Python]\n...\n# [Java]\n...\n# [JavaScript]\n...\n</code></pre>"},{"location":"tools/improve/#dedicated-label-for-best-practices-suggestions","title":"Dedicated label for best practices suggestions","text":"<p>Best practice suggestions are labeled as <code>Organization best practice</code> by default.  To customize this label, modify it in your configuration file:</p> <pre><code>[best_practices]\norganization_name = \"...\"\n</code></pre> <p>And the label will be: <code>{organization_name} best practice</code>.</p>"},{"location":"tools/improve/#example-results","title":"Example results","text":""},{"location":"tools/improve/#auto-best-practices","title":"Auto best practices","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub.</code></p> <p><code>Auto best practices</code> is a novel Qodo Merge capability that:</p> <ol> <li>Identifies recurring patterns from accepted suggestions</li> <li>Automatically generates best practices page based on what your team consistently values</li> <li>Applies these learned patterns to future code reviews</li> </ol> <p>This creates an automatic feedback loop where the system continuously learns from your team's choices to provide increasingly relevant suggestions.  The system maintains two analysis phases:</p> <ul> <li>Open exploration for new issues</li> <li>Targeted checking against established best practices</li> </ul> <p>Note that when a custom best practices exist, Qodo Merge will still generate an 'auto best practices' wiki file, though it won't use it in the <code>improve</code> tool. Learn more about utilizing 'auto best practices' in our detailed guide.</p>"},{"location":"tools/improve/#relevant-configurations","title":"Relevant configurations","text":"<pre><code>[auto_best_practices]\n# Disable all auto best practices usage or generation\nenable_auto_best_practices = true  \n\n# Disable usage of auto best practices file in the 'improve' tool\nutilize_auto_best_practices = true \n\n# Extra instructions to the auto best practices generation prompt\nextra_instructions = \"\"            \n\n# Max number of patterns to be detected\nmax_patterns = 5                   \n</code></pre>"},{"location":"tools/improve/#combining-extra-instructions-and-best-practices","title":"Combining 'extra instructions' and 'best practices'","text":"<p><code>\ud83d\udc8e feature</code></p> <p>The <code>extra instructions</code> configuration is more related to the <code>improve</code> tool prompt. It can be used, for example, to avoid specific suggestions (\"Don't suggest to add try-except block\", \"Ignore changes in toml files\", ...) or to emphasize specific aspects or formats (\"Answer in Japanese\", \"Give only short suggestions\", ...)</p> <p>In contrast, the <code>best_practices.md</code> file is a general guideline for the way code should be written in the repo.</p> <p>Using a combination of both can help the AI model to provide relevant and tailored suggestions.</p>"},{"location":"tools/improve/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/improve/#implementing-the-proposed-code-suggestions","title":"Implementing the proposed code suggestions","text":"<p>Each generated suggestion consists of three key elements:</p> <ol> <li>A single-line summary of the proposed change</li> <li>An expandable section containing a comprehensive description of the suggestion</li> <li>A diff snippet showing the recommended code modification (before and after)</li> </ol> <p>We advise users to apply critical analysis and judgment when implementing the proposed suggestions. In addition to mistakes (which may happen, but are rare), sometimes the presented code modification may serve more as an illustrative example than a direct applicable solution. In such cases, we recommend prioritizing the suggestion's detailed description, using the diff snippet primarily as a supporting reference.</p>"},{"location":"tools/improve/#dual-publishing-mode","title":"Dual publishing mode","text":"<p>Our recommended approach for presenting code suggestions is through a table (<code>--pr_code_suggestions.commitable_code_suggestions=false</code>). This method significantly reduces the PR footprint and allows for quick and easy digestion of multiple suggestions.</p> <p>We also offer a complementary dual publishing mode. When enabled, suggestions exceeding a certain score threshold are not only displayed in the table, but also presented as commitable PR comments. This mode helps highlight suggestions deemed more critical.</p> <p>To activate dual publishing mode, use the following setting:</p> <pre><code>[pr_code_suggestions]\ndual_publishing_score_threshold = x\n</code></pre> <p>Where x represents the minimum score threshold (&gt;=) for suggestions to be presented as commitable PR comments in addition to the table. Default is -1 (disabled).</p>"},{"location":"tools/improve/#self-review","title":"Self-review","text":"<p><code>\ud83d\udc8e feature</code></p> <p>If you set in a configuration file: <pre><code>[pr_code_suggestions]\ndemand_code_suggestions_self_review = true\n</code></pre></p> <p>The <code>improve</code> tool will add a checkbox below the suggestions, prompting user to acknowledge that they have reviewed the suggestions. You can set the content of the checkbox text via: <pre><code>[pr_code_suggestions]\ncode_suggestions_self_review_text = \"... (your text here) ...\"\n</code></pre></p> <p></p> <p>Tip - Reducing visual footprint after self-review \ud83d\udc8e</p> <p>The configuration parameter <code>pr_code_suggestions.fold_suggestions_on_self_review</code> (default is True) can be used to automatically fold the suggestions after the user clicks the self-review checkbox.</p> <p>This reduces the visual footprint of the suggestions, and also indicates to the PR reviewer that the suggestions have been reviewed by the PR author, and don't require further attention.</p> <p>Tip - Demanding self-review from the PR author \ud83d\udc8e</p> <p>By setting: <pre><code>[pr_code_suggestions]\napprove_pr_on_self_review = true\n</code></pre> the tool can automatically add an approval when the PR author clicks the self-review checkbox.</p> <ul> <li>If you set the number of required reviewers for a PR to 2, this effectively means that the PR author must click the self-review checkbox before the PR can be merged (in addition to a human reviewer).</li> </ul> <p></p> <ul> <li> <p>If you keep the number of required reviewers for a PR to 1 and enable this configuration, this effectively means that the PR author can approve the PR by actively clicking the self-review checkbox.</p> <p>To prevent unauthorized approvals, this configuration defaults to false, and cannot be altered through online comments; enabling requires a direct update to the configuration file and a commit to the repository. This ensures that utilizing the feature demands a deliberate documented decision by the repository owner.</p> </li> </ul>"},{"location":"tools/improve/#auto-approval","title":"Auto-approval","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>Under specific conditions, Qodo Merge can auto-approve a PR when a specific comment is invoked, or when the PR meets certain criteria.</p> <p>To ensure safety, the auto-approval feature is disabled by default. To enable auto-approval, you need to actively set, in a pre-defined configuration file, the following: <pre><code>[config]\nenable_auto_approval = true\n</code></pre> Note that this specific flag cannot be set with a command line argument, only in the configuration file, committed to the repository. This ensures that enabling auto-approval is a deliberate decision by the repository owner.</p> <p>(1) Auto-approval by commenting</p> <p>After enabling, by commenting on a PR: <pre><code>/review auto_approve\n</code></pre> Qodo Merge will automatically approve the PR, and add a comment with the approval.</p> <p>(2) Auto-approval when the PR meets certain criteria</p> <p>There are two criteria that can be set for auto-approval:</p> <ul> <li>Review effort score <pre><code>[config]\nauto_approve_for_low_review_effort = X # X is a number between 1 to 5\n</code></pre> When the review effort score is lower or equal to X, the PR will be auto-approved.</li> </ul> <ul> <li>No code suggestions <pre><code>[config]\nauto_approve_for_no_suggestions = true\n</code></pre> When no code suggestion were found for the PR, the PR will be auto-approved.</li> </ul>"},{"location":"tools/improve/#how-many-code-suggestions-are-generated","title":"How many code suggestions are generated?","text":"<p>Qodo Merge uses a dynamic strategy to generate code suggestions based on the size of the pull request (PR). Here's how it works:</p>"},{"location":"tools/improve/#1-chunking-large-prs","title":"1. Chunking large PRs","text":"<ul> <li>Qodo Merge divides large PRs into 'chunks'.</li> <li>Each chunk contains up to <code>pr_code_suggestions.max_context_tokens</code> tokens (default: 14,000).</li> </ul>"},{"location":"tools/improve/#2-generating-suggestions","title":"2. Generating suggestions","text":"<ul> <li>For each chunk, Qodo Merge generates up to <code>pr_code_suggestions.num_code_suggestions_per_chunk</code> suggestions (default: 4).</li> </ul> <p>This approach has two main benefits:</p> <ul> <li>Scalability: The number of suggestions scales with the PR size, rather than being fixed.</li> <li>Quality: By processing smaller chunks, the AI can maintain higher quality suggestions, as larger contexts tend to decrease AI performance.</li> </ul> <p>Note: Chunking is primarily relevant for large PRs. For most PRs (up to 500 lines of code), Qodo Merge will be able to process the entire code in a single call.</p>"},{"location":"tools/improve/#configuration-options","title":"Configuration options","text":"General options <p> extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". commitable_code_suggestions If set to true, the tool will display the suggestions as commitable code comments. Default is false. dual_publishing_score_threshold Minimum score threshold for suggestions to be presented as commitable PR comments in addition to the table. Default is -1 (disabled). focus_only_on_problems If set to true, suggestions will focus primarily on identifying and fixing code problems, and less on style considerations like best practices, maintainability, or readability. Default is true. persistent_comment If set to true, the improve comment will be persistent, meaning that every new improve request will edit the previous one. Default is false. suggestions_score_threshold  Any suggestion with importance score less than this threshold will be removed. Default is 0. Highly recommend not to set this value above 7-8, since above it may clip relevant suggestions that can be useful.  apply_suggestions_checkbox  Enable the checkbox to create a committable suggestion. Default is true. enable_more_suggestions_checkbox  Enable the checkbox to generate more suggestions. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is true. enable_chat_text If set to true, the tool will display a reference to the PR chat in the comment. Default is true. wiki_page_accepted_suggestions If set to true, the tool will automatically track accepted suggestions in a dedicated wiki page called <code>.pr_agent_accepted_suggestions</code>. Default is true. allow_thumbs_up_down If set to true, all code suggestions will have thumbs up and thumbs down buttons, to encourage users to provide feedback on the suggestions. Default is false. </p> Params for number of suggestions and AI calls <p> auto_extended_mode Enable chunking the PR code and running the tool on each chunk. Default is true. num_code_suggestions_per_chunk Number of code suggestions provided by the 'improve' tool, per chunk. Default is 4. max_number_of_calls Maximum number of chunks. Default is 3. </p>"},{"location":"tools/improve/#a-note-on-code-suggestions-quality","title":"A note on code suggestions quality","text":"<ul> <li>AI models for code are getting better and better (Sonnet-3.5 and GPT-4), but they are not flawless. Not all the suggestions will be perfect, and a user should not accept all of them automatically. Critical reading and judgment are required.</li> <li>While mistakes of the AI are rare but can happen, a real benefit from the suggestions of the <code>improve</code> (and <code>review</code>) tool is to catch, with high probability, mistakes or bugs done by the PR author, when they happen. So, it's a good practice to spend the needed ~30-60 seconds to review the suggestions, even if not all of them are always relevant.</li> <li> <p>The hierarchical structure of the suggestions is designed to help the user to quickly understand them, and to decide which ones are relevant and which are not:</p> <ul> <li>Only if the <code>Category</code> header is relevant, the user should move to the summarized suggestion description</li> <li>Only if the summarized suggestion description is relevant, the user should click on the collapsible, to read the full suggestion description with a code preview example.</li> </ul> </li> <li> <p>In addition, we recommend to use the <code>extra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.</p> </li> <li>The interactive PR chat also provides an easy way to get more tailored suggestions and feedback from the AI model.</li> </ul>"},{"location":"tools/improve_component/","title":"\ud83d\udc8e Improve Component","text":""},{"location":"tools/improve_component/#overview","title":"Overview","text":"<p>The <code>improve_component</code> tool generates code suggestions for a specific code component that changed in the PR. it can be invoked manually by commenting on any PR: <pre><code>/improve_component component_name\n</code></pre></p> <p>To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/improve_component/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/improve_component</code> on any PR:</p> <p></p> <p>The tool will generate code suggestions for the selected component (if no component is stated, it will generate code suggestions for the largest component):</p> <p></p> <p>Notes</p> <ul> <li>Language that are currently supported by the tool: Python, Java, C++, JavaScript, TypeScript, C#.</li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/improve_component/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_code_suggestions</code>: number of code suggestions to provide. Default is 4</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul>"},{"location":"tools/review/","title":"Review","text":""},{"location":"tools/review/#overview","title":"Overview","text":"<p>The <code>review</code> tool scans the PR code changes, and generates a list of feedbacks about the PR, aiming to aid the reviewing process.  The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on any PR: <pre><code>/review\n</code></pre></p> <p>Note that the main purpose of the <code>review</code> tool is to provide the PR reviewer with useful feedbacks and insights. The PR author, in contrast, may prefer to save time and focus on the output of the improve tool, which provides actionable code suggestions.</p> <p>(Read more about the different personas in the PR process and how Qodo Merge aims to assist them in our blog)</p>"},{"location":"tools/review/#example-usage","title":"Example usage","text":""},{"location":"tools/review/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/review</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a review for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command: <pre><code>/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n</code></pre></p>"},{"location":"tools/review/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>review</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/review\",\n    ...\n]\n\n[pr_reviewer]\nextra_instructions = \"...\"\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_reviewer]</code> section contains the configurations for the <code>review</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/review/#configuration-options","title":"Configuration options","text":"<p>General options</p> persistent_comment If set to true, the review comment will be persistent, meaning that every new review request will edit the previous one. Default is true. final_update_message When set to true, updating a persistent review comment during online commenting will automatically add a short comment with a link to the updated review in the pull request .Default is true. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". enable_help_text If set to true, the tool will display a help text in the comment. Default is true. <p>Enable\\disable specific sub-sections</p> require_score_review If set to true, the tool will add a section that scores the PR. Default is false. require_tests_review If set to true, the tool will add a section that checks if the PR contains tests. Default is true. require_estimate_effort_to_review If set to true, the tool will add a section that estimates the effort needed to review the PR. Default is true. require_can_be_split_review If set to true, the tool will add a section that checks if the PR contains several themes, and can be split into smaller PRs. Default is false. require_security_review If set to true, the tool will add a section that checks if the PR contains a possible security or vulnerability issue. Default is true. require_ticket_analysis_review If set to true, and the PR contains a GitHub or Jira ticket link, the tool will add a section that checks if the PR in fact fulfilled the ticket requirements. Default is true. <p>Adding PR labels</p> <p>You can enable\\disable the <code>review</code> tool to add specific labels to the PR:</p> enable_review_labels_security If set to true, the tool will publish a 'possible security issue' label if it detects a security issue. Default is true. enable_review_labels_effort If set to true, the tool will publish a 'Review effort [1-5]: x' label. Default is true."},{"location":"tools/review/#usage-tips","title":"Usage Tips","text":"<p>General guidelines</p> <p>The <code>review</code> tool provides a collection of configurable feedbacks about a PR. It is recommended to review the Configuration options section, and choose the relevant options for your use case.</p> <p>Some of the features that are disabled by default are quite useful, and should be considered for enabling. For example: <code>require_score_review</code>, and more.</p> <p>On the other hand, if you find one of the enabled features to be irrelevant for your use case, disable it. No default configuration can fit all use cases.</p> <p>Automation</p> <p>When you first install Qodo Merge app, the default mode for the <code>review</code> tool is: <pre><code>pr_commands = [\"/review\", ...]\n</code></pre> Meaning the <code>review</code> tool will run automatically on every PR, without any additional configurations. Edit this field to enable/disable the tool, or to change the configurations used.</p> <p>Possible labels from the review tool</p> <p>The <code>review</code> tool can auto-generate two specific types of labels for a PR:</p> <ul> <li>a <code>possible security issue</code> label that detects if a possible security issue exists in the PR code (<code>enable_review_labels_security</code> flag)</li> <li>a <code>Review effort [1-5]: x</code> label, where x is the estimated effort to review the PR (<code>enable_review_labels_effort</code> flag)</li> </ul> <p>Both modes are useful, and we recommended to enable them.</p> <p>Extra instructions</p> <p>Extra instructions are important. The <code>review</code> tool can be configured with extra instructions, which can be used to guide the model to a feedback tailored to the needs of your project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify the relevant sub-tool, and the relevant aspects of the PR that you want to emphasize.</p> <p>Examples of extra instructions: <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\nIn the code feedback section, emphasize the following:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.</p> <p>Code suggestions</p> <p>The <code>review</code> tool previously included a legacy feature for providing code suggestions (controlled by <code>--pr_reviewer.num_code_suggestion</code>). This functionality has been deprecated and replaced by the <code>improve</code> tool, which offers higher quality and more actionable code suggestions.</p>"},{"location":"tools/similar_code/","title":"\ud83d\udc8e Similar Code","text":""},{"location":"tools/similar_code/#overview","title":"Overview","text":"<p>The similar code tool retrieves the most similar code components from inside the organization's codebase, or from open-source code.</p> <p>For example:</p> <p><code>Global Search</code> for a method called <code>chat_completion</code>:</p> <p></p> <p>Qodo Merge will examine the code component and will extract the most relevant keywords to search for similar code:</p> <ul> <li><code>extracted keywords</code>: the keywords that were extracted from the code by Qodo Merge. the link will open a search page with the extracted keywords, to allow the user to modify the search if needed.</li> <li><code>search context</code>: the context in which the search will be performed, organization's codebase or open-source code (Global).</li> <li><code>similar code</code>: the most similar code components found. the link will open the code component in the relevant file.</li> <li><code>relevant repositories</code>: the open-source repositories in which that are relevant to the searched code component and it's keywords.</li> </ul> <p>Search result link example:</p> <p></p> <p><code>Organization Search</code>:</p> <p></p>"},{"location":"tools/similar_code/#how-to-use","title":"How to use","text":""},{"location":"tools/similar_code/#manually","title":"Manually","text":"<p>To invoke the <code>similar code</code> tool manually, comment on the PR: <pre><code>/find_similar_component COMPONENT_NAME\n</code></pre> Where <code>COMPONENT_NAME</code> should be the name of a code component in the PR (class, method, function).</p> <p>If there is a name ambiguity, there are two configurations that will help the tool to find the correct component:</p> <ul> <li><code>--pr_find_similar_component.file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>--pr_find_similar_component.class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul> <p>example: <pre><code>/find_similar_component COMPONENT_NAME --pr_find_similar_component.file=FILE_NAME\n</code></pre></p>"},{"location":"tools/similar_code/#automatically-via-analyze-table","title":"Automatically (via Analyze table)","text":"<p>It can be invoked automatically from the analyze table, can be accessed by: <pre><code>/analyze\n</code></pre> Choose the components you want to find similar code for, and click on the <code>similar</code> checkbox.</p> <p></p> <p>You can search for similar code either within the organization's codebase or globally, which includes open-source repositories. Each result will include the relevant code components along with their associated license details.</p> <p></p>"},{"location":"tools/similar_code/#configuration-options","title":"Configuration options","text":"<ul> <li><code>search_from_org</code>: if set to true, the tool will search for similar code in the organization's codebase. Default is false.</li> <li><code>number_of_keywords</code>: number of keywords to use for the search. Default is 5.</li> <li><code>number_of_results</code>: the maximum number of results to present. Default is 5.</li> </ul>"},{"location":"tools/similar_issues/","title":"Similar Issues","text":""},{"location":"tools/similar_issues/#overview","title":"Overview","text":"<p>The similar issue tool retrieves the most similar issues to the current issue. It can be invoked manually by commenting on any PR: <pre><code>/similar_issue\n</code></pre></p>"},{"location":"tools/similar_issues/#example-usage","title":"Example usage","text":"<p>Note that to perform retrieval, the <code>similar_issue</code> tool indexes all the repo previous issues (once).</p>"},{"location":"tools/similar_issues/#selecting-a-vector-database","title":"Selecting a Vector Database","text":"<p>Configure your preferred database by changing the <code>pr_similar_issue</code> parameter in <code>configuration.toml</code> file.</p>"},{"location":"tools/similar_issues/#available-options","title":"Available Options","text":"<p>Choose from the following Vector Databases:</p> <ol> <li>LanceDB</li> <li>Pinecone</li> </ol>"},{"location":"tools/similar_issues/#pinecone-configuration","title":"Pinecone Configuration","text":"<p>To use Pinecone with the <code>similar issue</code> tool, add these credentials to <code>.secrets.toml</code> (or set as environment variables):</p> <p><pre><code>[pinecone]\napi_key = \"...\"\nenvironment = \"...\"\n</code></pre> These parameters can be obtained by registering to Pinecone.</p>"},{"location":"tools/similar_issues/#how-to-use","title":"How to use","text":"<ul> <li> <p>To invoke the 'similar issue' tool from CLI, run: <code>python3 cli.py --issue_url=... similar_issue</code></p> </li> <li> <p>To invoke the 'similar' issue tool via online usage, comment on a PR: <code>/similar_issue</code></p> </li> <li> <p>You can also enable the 'similar issue' tool to run automatically when a new issue is opened, by adding it to the pr_commands list in the github_app section</p> </li> </ul>"},{"location":"tools/test/","title":"\ud83d\udc8e Test","text":""},{"location":"tools/test/#overview","title":"Overview","text":"<p>By combining LLM abilities with static code analysis, the <code>test</code> tool  generate tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR: <pre><code>/test component_name\n</code></pre> where 'component_name' is the name of a specific component in the PR. To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/test/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/test</code> on any PR: The tool will generate tests for the selected component (if no component is stated, it will generate tests for largest component):</p> <p></p> <p>(Example taken from here):</p> <p>Notes</p> <ul> <li>The following languages are currently supported: Python, Java, C++, JavaScript, TypeScript, C#.</li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/test/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_tests</code>: number of tests to generate. Default is 3.</li> <li><code>testing_framework</code>: the testing framework to use. If not set, for Python it will use <code>pytest</code>, for Java it will use <code>JUnit</code>, for C++ it will use <code>Catch2</code>, and for JavaScript and TypeScript it will use <code>jest</code>.</li> <li><code>avoid_mocks</code>: if set to true, the tool will try to avoid using mocks in the generated tests. Note that even if this option is set to true, the tool might still use mocks if it cannot generate a test without them. Default is true.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"use the following mock injection scheme: ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> <li><code>enable_help_text</code>: if set to true, the tool will add a help text to the PR comment. Default is true.</li> </ul>"},{"location":"tools/update_changelog/","title":"Update Changelog","text":""},{"location":"tools/update_changelog/#overview","title":"Overview","text":"<p>The <code>update_changelog</code> tool automatically updates the CHANGELOG.md file with the PR changes. It can be invoked manually by commenting on any PR: <pre><code>/update_changelog\n</code></pre></p>"},{"location":"tools/update_changelog/#example-usage","title":"Example usage","text":""},{"location":"tools/update_changelog/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_update_changelog</code>, the configuration file contains options to customize the 'update changelog' tool:</p> <ul> <li><code>push_changelog_changes</code>: whether to push the changes to CHANGELOG.md, or just print them. Default is false (print only).</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...</li> <li><code>add_pr_link</code>: whether the model should try to add a link to the PR in the changelog. Default is true.</li> </ul>"},{"location":"usage-guide/","title":"Usage guide","text":"<p>This page provides a detailed guide on how to use Qodo Merge. It includes information on how to adjust Qodo Merge configurations, define which tools will run automatically, and other advanced configurations.</p> <ul> <li>Introduction</li> <li>Enabling a Wiki</li> <li>Configuration File</li> <li>Usage and Automation<ul> <li>Local Repo (CLI)</li> <li>Online Usage</li> <li>GitHub App</li> <li>GitHub Action</li> <li>GitLab Webhook</li> <li>BitBucket App</li> <li>Azure DevOps Provider</li> </ul> </li> <li>Managing Mail Notifications</li> <li>Changing a Model</li> <li>Additional Configurations Walkthrough<ul> <li>Ignoring files from analysis</li> <li>Extra instructions</li> <li>Working with large PRs</li> <li>Changing a model</li> <li>Patch Extra Lines</li> <li>Editing the prompts</li> </ul> </li> <li>Qodo Merge Models</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/","title":"EXAMPLE BEST PRACTICE","text":""},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#recommend-python-best-practices","title":"Recommend Python Best Practices","text":"<p>This document outlines a series of recommended best practices for Python development. These guidelines aim to improve code quality, maintainability, and readability.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#imports","title":"Imports","text":"<p>Use  <code>import</code>  statements for packages and modules only, not for individual types, classes, or functions.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition","title":"Definition","text":"<p>Reusability mechanism for sharing code from one module to another.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision","title":"Decision","text":"<ul> <li>Use  <code>import x</code>  for importing packages and modules.</li> <li>Use  <code>from x import y</code>  where  <code>x</code>  is the package prefix and  <code>y</code>  is the module name with no prefix.</li> <li>Use  <code>from x import y as z</code>  in any of the following circumstances:<ul> <li>Two modules named  <code>y</code>  are to be imported.</li> <li><code>y</code>  conflicts with a top-level name defined in the current module.</li> <li><code>y</code>  conflicts with a common parameter name that is part of the public API (e.g.,  <code>features</code>).</li> <li><code>y</code>  is an inconveniently long name, or too generic in the context of your code</li> </ul> </li> <li>Use  <code>import y as z</code>  only when  <code>z</code>  is a standard abbreviation (e.g.,  <code>import numpy as np</code>).</li> </ul> <p>For example the module  <code>sound.effects.echo</code>  may be imported as follows:</p> <pre><code>from sound.effects import echo\n...\necho.EchoFilter(input, output, delay=0.7, atten=4)\n</code></pre> <p>Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#exemptions","title":"Exemptions","text":"<p>Exemptions from this rule:</p> <ul> <li>Symbols from the following modules are used to support static analysis and type checking:<ul> <li><code>typing</code>  module</li> <li><code>collections.abc</code>  module</li> <li><code>typing_extensions</code>  module</li> </ul> </li> <li>Redirects from the  six.moves module.</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#packages","title":"Packages","text":"<p>Import each module using the full pathname location of the module.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_1","title":"Decision","text":"<p>All new code should import each module by its full package name.</p> <p>Imports should be as follows:</p> <pre><code>Yes:\n  # Reference absl.flags in code with the complete name (verbose).\n  import absl.flags\n  from doctor.who import jodie\n\n  _FOO = absl.flags.DEFINE_string(...)\n</code></pre> <pre><code>Yes:\n  # Reference flags in code with just the module name (common).\n  from absl import flags\n  from doctor.who import jodie\n\n  _FOO = flags.DEFINE_string(...)\n</code></pre> <p>(assume this file lives in  <code>doctor/who/</code>  where  <code>jodie.py</code>  also exists)</p> <pre><code>No:\n  # Unclear what module the author wanted and what will be imported.  The actual\n  # import behavior depends on external factors controlling sys.path.\n  # Which possible jodie module did the author intend to import?\n  import jodie\n</code></pre> <p>The directory the main binary is located in should not be assumed to be in  <code>sys.path</code>  despite that happening in some environments. This being the case, code should assume that  <code>import jodie</code>  refers to a third-party or top-level package named  <code>jodie</code>, not a local  <code>jodie.py</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-iterators-and-operators","title":"Default Iterators and Operators","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_1","title":"Definition","text":"<p>Container types, like dictionaries and lists, define default iterators and membership test operators (\u201cin\u201d and \u201cnot in\u201d).</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_2","title":"Decision","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.</p> <pre><code>Yes:  for key in adict: ...\n      if obj in alist: ...\n      for line in afile: ...\n      for k, v in adict.items(): ...\n</code></pre> <pre><code>No:   for key in adict.keys(): ...\n      for line in afile.readlines(): ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lambda-functions","title":"Lambda Functions","text":"<p>Okay for one-liners. Prefer generator expressions over  <code>map()</code>  or  <code>filter()</code>  with a  <code>lambda</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_3","title":"Decision","text":"<p>Lambdas are allowed. If the code inside the lambda function spans multiple lines or is longer than 60-80 chars, it might be better to define it as a regular  nested function.</p> <p>For common operations like multiplication, use the functions from the  <code>operator</code>  module instead of lambda functions. For example, prefer  <code>operator.mul</code>  to  <code>lambda x, y: x * y</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-argument-values","title":"Default Argument Values","text":"<p>Okay in most cases.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_2","title":"Definition","text":"<p>You can specify values for variables at the end of a function\u2019s parameter list, e.g.,  <code>def foo(a, b=0):</code>. If  <code>foo</code>  is called with only one argument,  <code>b</code>  is set to 0. If it is called with two arguments,  <code>b</code>  has the value of the second argument.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_4","title":"Decision","text":"<p>Okay to use with the following caveat:</p> <p>Do not use mutable objects as default values in the function or method definition.</p> <pre><code>Yes: def foo(a, b=None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence | None = None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable.\n         ...\n</code></pre> <pre><code>from absl import flags\n_FOO = flags.DEFINE_string(...)\n\nNo:  def foo(a, b=[]):\n         ...\nNo:  def foo(a, b=time.time()):  # Is `b` supposed to represent when this module was loaded?\n         ...\nNo:  def foo(a, b=_FOO.value):  # sys.argv has not yet been parsed...\n         ...\nNo:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code.\n         ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#truefalse-evaluations","title":"True/False Evaluations","text":"<p>Use the \u201cimplicit\u201d false if possible, e.g.,  <code>if foo:</code>  rather than  <code>if foo != []:</code></p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lexical-scoping","title":"Lexical Scoping","text":"<p>Okay to use.</p> <p>An example of the use of this feature is:</p> <pre><code>def get_adder(summand1: float) -&gt; Callable[[float], float]:\n    \"\"\"Returns a function that adds numbers to a given number.\"\"\"\n    def adder(summand2: float) -&gt; float:\n        return summand1 + summand2\n\n    return adder\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_5","title":"Decision","text":"<p>Okay to use.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#threading","title":"Threading","text":"<p>Do not rely on the atomicity of built-in types.</p> <p>While Python\u2019s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren\u2019t atomic (e.g. if  <code>__hash__</code>  or  <code>__eq__</code>  are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</p> <p>Use the  <code>queue</code>  module\u2019s  <code>Queue</code>  data type as the preferred way to communicate data between threads. Otherwise, use the  <code>threading</code>  module and its locking primitives. Prefer condition variables and  <code>threading.Condition</code>  instead of using lower-level locks.</p>"},{"location":"usage-guide/additional_configurations/","title":"Additional Configurations","text":""},{"location":"usage-guide/additional_configurations/#show-possible-configurations","title":"Show possible configurations","text":"<p>The possible configurations of Qodo Merge are stored in here. In the tools page you can find explanations on how to use these configurations for each tool.</p> <p>To print all the available configurations as a comment on your PR, you can use the following command: <pre><code>/config\n</code></pre></p> <p></p> <p>To view the actual configurations used for a specific tool, after all the user settings are applied, you can add for each tool a <code>--config.output_relevant_configurations=true</code> suffix. For example: <pre><code>/improve --config.output_relevant_configurations=true\n</code></pre> Will output an additional field showing the actual configurations used for the <code>improve</code> tool.</p> <p></p>"},{"location":"usage-guide/additional_configurations/#ignoring-files-from-analysis","title":"Ignoring files from analysis","text":"<p>In some cases, you may want to exclude specific files or directories from the analysis performed by Qodo Merge. This can be useful, for example, when you have files that are generated automatically or files that shouldn't be reviewed, like vendor code.</p> <p>You can ignore files or folders using the following methods:  - <code>IGNORE.GLOB</code>  - <code>IGNORE.REGEX</code></p> <p>which you can edit to ignore files or folders based on glob or regex patterns.</p>"},{"location":"usage-guide/additional_configurations/#example-usage","title":"Example usage","text":"<p>Let's look at an example where we want to ignore all files with <code>.py</code> extension from the analysis.</p> <p>To ignore Python files in a PR with online usage, comment on a PR: <code>/review --ignore.glob=\"['*.py']\"</code></p> <p>To ignore Python files in all PRs using <code>glob</code> pattern, set in a configuration file: <pre><code>[ignore]\nglob = ['*.py']\n</code></pre></p> <p>And to ignore Python files in all PRs using <code>regex</code> pattern, set in a configuration file: <pre><code>[regex]\nregex = ['.*\\.py$']\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#extra-instructions","title":"Extra instructions","text":"<p>All Qodo Merge tools have a parameter called <code>extra_instructions</code>, that enables to add free-text extra instructions. Example usage: <pre><code>/update_changelog --pr_update_changelog.extra_instructions=\"Make sure to update also the version ...\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#language-settings","title":"Language Settings","text":"<p>The default response language for Qodo Merge is U.S. English. However, some development teams may prefer to display information in a different language. For example, your team's workflow might improve if PR descriptions and code suggestions are set to your country's native language.  </p> <p>To configure this, set the <code>response_language</code> parameter in the configuration file. This will prompt the model to respond in the specified language. Use a standard locale code based on ISO 3166 (country codes) and ISO 639 (language codes) to define a language-country pair. See this comprehensive list of locale codes.  </p> <p>Example: </p> <pre><code>[config]\nresponse_language: \"it-IT\"\n</code></pre> <p>This will set the response language globally for all the commands to Italian.</p> <p>Important: Note that only dynamic text generated by the AI model is translated to the configured language. Static text such as labels and table headers that are not part of the AI models response will remain in US English. In addition, the model you are using must have good support for the specified language. </p>"},{"location":"usage-guide/additional_configurations/#working-with-large-prs","title":"Working with large PRs","text":"<p>The default mode of CodiumAI is to have a single call per tool, using GPT-4, which has a token limit of 8000 tokens. This mode provides a very good speed-quality-cost tradeoff, and can handle most PRs successfully. When the PR is above the token limit, it employs a PR Compression strategy.</p> <p>However, for very large PRs, or in case you want to emphasize quality over speed and cost, there are two possible solutions: 1) Use a model with larger context, like GPT-32K, or claude-100K. This solution will be applicable for all the tools. 2) For the <code>/improve</code> tool, there is an 'extended' mode (<code>/improve --extended</code>), which divides the PR into chunks, and processes each chunk separately. With this mode, regardless of the model, no compression will be done (but for large PRs, multiple model calls may occur)</p>"},{"location":"usage-guide/additional_configurations/#patch-extra-lines","title":"Patch Extra Lines","text":"<p>By default, around any change in your PR, git patch provides three lines of context above and below the change. <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n</code></pre></p> <p>Qodo Merge will try to increase the number of lines of context, via the parameter: <pre><code>[config]\npatch_extra_lines_before=3\npatch_extra_lines_after=1\n</code></pre></p> <p>Increasing this number provides more context to the model, but will also increase the token budget, and may overwhelm the model with too much information, unrelated to the actual PR code changes.</p> <p>If the PR is too large (see PR Compression strategy), Qodo Merge may automatically set this number to 0, and will use the original git patch.</p>"},{"location":"usage-guide/additional_configurations/#editing-the-prompts","title":"Editing the prompts","text":"<p>The prompts for the various Qodo Merge tools are defined in the <code>pr_agent/settings</code> folder. In practice, the prompts are loaded and stored as a standard setting object. Hence, editing them is similar to editing any other configuration value - just place the relevant key in <code>.pr_agent.toml</code>file, and override the default value.</p> <p>For example, if you want to edit the prompts of the describe tool, you can add the following to your <code>.pr_agent.toml</code> file: <pre><code>[pr_description_prompt]\nsystem=\"\"\"\n...\n\"\"\"\nuser=\"\"\"\n...\n\"\"\"\n</code></pre> Note that the new prompt will need to generate an output compatible with the relevant post-process function.</p>"},{"location":"usage-guide/additional_configurations/#integrating-with-logging-observability-platforms","title":"Integrating with Logging Observability Platforms","text":"<p>Various logging observability tools can be used out-of-the box when using the default LiteLLM AI Handler. Simply configure the LiteLLM callback settings in <code>configuration.toml</code> and set environment variables according to the LiteLLM documentation.</p> <p>For example, to use LangSmith you can add the following to your <code>configuration.toml</code> file: <pre><code>[litellm]\nenable_callbacks = true\nsuccess_callback = [\"langsmith\"]\nfailure_callback = [\"langsmith\"]\nservice_callback = []\n</code></pre></p> <p>Then set the following environment variables:</p> <pre><code>LANGSMITH_API_KEY=&lt;api_key&gt;\nLANGSMITH_PROJECT=&lt;project&gt;\nLANGSMITH_BASE_URL=&lt;url&gt;\n</code></pre>"},{"location":"usage-guide/additional_configurations/#ignoring-automatic-commands-in-prs","title":"Ignoring automatic commands in PRs","text":"<p>Qodo Merge allows you to automatically ignore certain PRs based on various criteria:</p> <ul> <li>PRs with specific titles (using regex matching)</li> <li>PRs between specific branches (using regex matching)</li> <li>PRs not from specific folders</li> <li>PRs containing specific labels</li> <li>PRs opened by specific users</li> </ul>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-with-specific-titles","title":"Ignoring PRs with specific titles","text":"<p>To ignore PRs with a specific title such as \"[Bump]: ...\", you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_title = [\"\\\\[Bump\\\\]\"]\n</code></pre> <p>Where the <code>ignore_pr_title</code> is a list of regex patterns to match the PR title you want to ignore. Default is <code>ignore_pr_title = [\"^\\\\[Auto\\\\]\", \"^Auto\"]</code>.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-between-specific-branches","title":"Ignoring PRs between specific branches","text":"<p>To ignore PRs from specific source or target branches, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_source_branches = ['develop', 'main', 'master', 'stage']\nignore_pr_target_branches = [\"qa\"]\n</code></pre> <p>Where the <code>ignore_pr_source_branches</code> and <code>ignore_pr_target_branches</code> are lists of regex patterns to match the source and target branches you want to ignore. They are not mutually exclusive, you can use them together or separately.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-not-from-specific-folders","title":"Ignoring PRs not from specific folders","text":"<p>To allow only specific folders (often needed in large monorepos), set:</p> <pre><code>[config]\nallow_only_specific_folders=['folder1','folder2']\n</code></pre> <p>For the configuration above, automatic feedback will only be triggered when the PR changes include files where 'folder1' or 'folder2' is in the file path</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-containing-specific-labels","title":"Ignoring PRs containing specific labels","text":"<p>To ignore PRs containg specific labels, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_labels = [\"do-not-merge\"]\n</code></pre> <p>Where the <code>ignore_pr_labels</code> is a list of labels that when present in the PR, the PR will be ignored.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-from-specific-users","title":"Ignoring PRs from specific users","text":"<p>Qodo Merge automatically identifies and ignores pull requests created by bots using:</p> <ul> <li>GitHub's native bot detection system</li> <li>Name-based pattern matching</li> </ul> <p>While this detection is robust, it may not catch all cases, particularly when:</p> <ul> <li>Bots are registered as regular user accounts</li> <li>Bot names don't match common patterns</li> </ul> <p>To supplement the automatic bot detection, you can manually specify users to ignore. Add the following to your <code>configuration.toml</code> file to ignore PRs from specific users: <pre><code>[config]\nignore_pr_authors = [\"my-special-bot-user\", ...]\n</code></pre></p> <p>Where the <code>ignore_pr_authors</code> is a list of usernames that you want to ignore.</p>"},{"location":"usage-guide/automations_and_usage/","title":"Usage and Automation","text":""},{"location":"usage-guide/automations_and_usage/#local-repo-cli","title":"Local repo (CLI)","text":"<p>When running from your locally cloned Qodo Merge repo (CLI), your local configuration file will be used. Examples of invoking the different tools via the CLI:</p> <ul> <li>Review:       <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  review</code></li> <li>Describe:     <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  describe</code></li> <li>Improve:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  improve</code></li> <li>Ask:          <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  ask \"Write me a poem about this PR\"</code></li> <li>Reflect:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  reflect</code></li> <li>Update Changelog:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  update_changelog</code></li> </ul> <p><code>&lt;pr_url&gt;</code> is the url of the relevant PR (for example: #50).</p> <p>Notes:</p> <ol> <li> <p>in addition to editing your local configuration file, you can also change any configuration value by adding it to the command line: <pre><code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  /review --pr_reviewer.extra_instructions=\"focus on the file: ...\"\n</code></pre></p> </li> <li> <p>You can print results locally, without publishing them, by setting in <code>configuration.toml</code>: <pre><code>[config]\npublish_output=false\nverbosity_level=2\n</code></pre> This is useful for debugging or experimenting with different tools.</p> </li> <li> <p>git provider: The git_provider field in a configuration file determines the GIT provider that will be used by Qodo Merge. Currently, the following providers are supported: <code>github</code> (default), <code>gitlab</code>, <code>bitbucket</code>, <code>azure</code>, <code>codecommit</code>, <code>local</code>, and <code>gerrit</code>.</p> </li> </ol>"},{"location":"usage-guide/automations_and_usage/#cli-health-check","title":"CLI Health Check","text":"<p>To verify that Qodo Merge has been configured correctly, you can run this health check command from the repository root:</p> <pre><code>python -m tests.health_test.main\n</code></pre> <p>If the health check passes, you will see the following output:</p> <pre><code>========\nHealth test passed successfully\n========\n</code></pre> <p>At the end of the run.</p> <p>Before running the health check, ensure you have:</p> <ul> <li>Configured your LLM provider</li> <li>Added a valid GitHub token to your configuration file</li> </ul>"},{"location":"usage-guide/automations_and_usage/#online-usage","title":"Online usage","text":"<p>Online usage means invoking Qodo Merge tools by comments on a PR. Commands for invoking the different tools via comments:</p> <ul> <li>Review:       <code>/review</code></li> <li>Describe:     <code>/describe</code></li> <li>Improve:      <code>/improve</code>  (or <code>/improve_code</code> for bitbucket, since <code>/improve</code> is sometimes reserved)</li> <li>Ask:          <code>/ask \"...\"</code></li> <li>Reflect:      <code>/reflect</code></li> <li>Update Changelog:      <code>/update_changelog</code></li> </ul> <p>To edit a specific configuration value, just add <code>--config_path=&lt;value&gt;</code> to any command. For example, if you want to edit the <code>review</code> tool configurations, you can run: <pre><code>/review --pr_reviewer.extra_instructions=\"...\" --pr_reviewer.require_score_review=false\n</code></pre> Any configuration value in configuration file file can be similarly edited. Comment <code>/config</code> to see the list of available configurations.</p>"},{"location":"usage-guide/automations_and_usage/#qodo-merge-automatic-feedback","title":"Qodo Merge Automatic Feedback","text":""},{"location":"usage-guide/automations_and_usage/#disabling-all-automatic-feedback","title":"Disabling all automatic feedback","text":"<p>To easily disable all automatic feedback from Qodo Merge (GitHub App, GitLab Webhook, BitBucket App, Azure DevOps Webhook), set in a configuration file:</p> <pre><code>[config]\ndisable_auto_feedback = true\n</code></pre> <p>When this parameter is set to <code>true</code>, Qodo Merge will not run any automatic tools (like <code>describe</code>, <code>review</code>, <code>improve</code>) when a new PR is opened, or when new code is pushed to an open PR.</p>"},{"location":"usage-guide/automations_and_usage/#github-app","title":"GitHub App","text":"<p>Configurations for Qodo Merge</p> <p>Qodo Merge for GitHub is an App, hosted by Qodo. So all the instructions below are relevant also for Qodo Merge users. Same goes for GitLab webhook and BitBucket App sections.</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened","title":"GitHub app automatic tools when a new PR is opened","text":"<p>The github_app section defines GitHub app specific configurations.</p> <p>The configuration parameter <code>pr_commands</code> defines the list of tools that will be run automatically when a new PR is opened: <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre></p> <p>This means that when a new PR is opened/reopened or marked as ready for review, Qodo Merge will run the <code>describe</code>, <code>review</code> and <code>improve</code> tools.  </p> <p>You can override the default tool parameters by using one the three options for a configuration file: wiki, local, or global. For example, if your configuration file contains:</p> <pre><code>[pr_description]\ngenerate_ai_title = true\n</code></pre> <p>Every time you run the <code>describe</code> tool (including automatic runs) the PR title will be generated by the AI.</p> <p>You can customize configurations specifically for automated runs by using the <code>--config_path=&lt;value&gt;</code> parameter. For instance, to modify the <code>review</code> tool settings only for newly opened PRs, use: <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review --pr_reviewer.extra_instructions='focus on the file: ...'\",\n    \"/improve\",\n]\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-for-push-actions-commits-to-an-open-pr","title":"GitHub app automatic tools for push actions (commits to an open PR)","text":"<p>In addition to running automatic tools when a PR is opened, the GitHub app can also respond to new code that is pushed to an open PR.</p> <p>The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the PR. <pre><code>[github_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre> This means that when new code is pushed to the PR, the Qodo Merge will run the <code>describe</code> and <code>review</code> tools, with the specified parameters.</p>"},{"location":"usage-guide/automations_and_usage/#github-action","title":"GitHub Action","text":"<p><code>GitHub Action</code> is a different way to trigger Qodo Merge tools, and uses a different configuration mechanism than <code>GitHub App</code>. You can configure settings for <code>GitHub Action</code> by adding environment variables under the env section in <code>.github/workflows/pr_agent.yml</code> file. Specifically, start by setting the following environment variables: <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }} # Make sure to add your OpenAI key to your repo secrets\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Make sure to add your GitHub token to your repo secrets\n        github_action_config.auto_review: \"true\" # enable\\disable auto review\n        github_action_config.auto_describe: \"true\" # enable\\disable auto describe\n        github_action_config.auto_improve: \"true\" # enable\\disable auto improve\n        github_action_config.pr_actions: '[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]'\n</code></pre> <code>github_action_config.auto_review</code>, <code>github_action_config.auto_describe</code> and <code>github_action_config.auto_improve</code> are used to enable/disable automatic tools that run when a new PR is opened. If not set, the default configuration is for all three tools to run automatically when a new PR is opened.</p> <p><code>github_action_config.pr_actions</code> is used to configure which <code>pull_requests</code> events will trigger the enabled auto flags If not set, the default configuration is <code>[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]</code></p> <p><code>github_action_config.enable_output</code> are used to enable/disable github actions output parameter (default is <code>true</code>). Review result is output as JSON to <code>steps.{step-id}.outputs.review</code> property. The JSON structure is equivalent to the yaml data structure defined in pr_reviewer_prompts.toml.</p> <p>Note that you can give additional config parameters by adding environment variables to <code>.github/workflows/pr_agent.yml</code>, or by using a <code>.pr_agent.toml</code> configuration file in the root of your repo</p> <p>For example, you can set an environment variable: <code>pr_description.publish_labels=false</code>, or add a <code>.pr_agent.toml</code> file with the following content:</p> <pre><code>[pr_description]\npublish_labels = false\n</code></pre> <p>to prevent Qodo Merge from publishing labels when running the <code>describe</code> tool.</p>"},{"location":"usage-guide/automations_and_usage/#gitlab-webhook","title":"GitLab Webhook","text":"<p>After setting up a GitLab webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[gitlab]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre> <p>the GitLab webhook can also respond to new code that is pushed to an open MR. The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the MR. <pre><code>[gitlab]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre></p> <p>Note that to use the 'handle_push_trigger' feature, you need to give the gitlab webhook also the \"Push events\" scope.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-app","title":"BitBucket App","text":"<p>Similar to GitHub app, when running Qodo Merge from BitBucket App, the default configuration file from a pre-built docker will be initially loaded.</p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if your local <code>.pr_agent.toml</code> file contains: <pre><code>[pr_reviewer]\nextra_instructions = \"Answer in japanese\"\n</code></pre></p> <p>Each time you invoke a <code>/review</code> tool, it will use the extra instructions you set in the local configuration file.</p> <p>Note that among other limitations, BitBucket provides relatively low rate-limits for applications (up to 1000 requests per hour), and does not provide an API to track the actual rate-limit usage. If you experience a lack of responses from Qodo Merge, you might want to set: <code>bitbucket_app.avoid_full_files=true</code> in your configuration file. This will prevent Qodo Merge from acquiring the full file content, and will only use the diff content. This will reduce the number of requests made to BitBucket, at the cost of small decrease in accuracy, as dynamic context will not be applicable.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-self-hosted-app-automatic-tools","title":"BitBucket Self-Hosted App automatic tools","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file: Specifically, set the following values:</p> <p><pre><code>[bitbucket_app]\npr_commands = [\n    \"/review\",\n    \"/improve --pr_code_suggestions.commitable_code_suggestions=true --pr_code_suggestions.suggestions_score_threshold=7\",\n]\n</code></pre> Note that we set specifically for bitbucket, we recommend using: <code>--pr_code_suggestions.suggestions_score_threshold=7</code> and that is the default value we set for bitbucket. Since this platform only supports inline code suggestions, we want to limit the number of suggestions, and only present a limited number.</p> <p>To enable BitBucket app to respond to each push to the PR, set (for example): <pre><code>[bitbucket_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App: <pre><code>[azure_devops_server]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre></p>"},{"location":"usage-guide/changing_a_model/","title":"Changing a Model","text":""},{"location":"usage-guide/changing_a_model/#changing-a-model-in-pr-agent","title":"Changing a model in PR-Agent","text":"<p>See here for a list of available models. To use a different model than the default (GPT-4), you need to edit in the configuration file the fields: <pre><code>[config]\nmodel = \"...\"\nfallback_models = [\"...\"]\n</code></pre></p> <p>For models and environments not from OpenAI, you might need to provide additional keys and other parameters. You can give parameters via a configuration file (see below for instructions), or from environment variables. See litellm documentation for the environment variables relevant per model.</p>"},{"location":"usage-guide/changing_a_model/#azure","title":"Azure","text":"<p>To use Azure, set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action): <pre><code>[openai]\nkey = \"\" # your azure api key\napi_type = \"azure\"\napi_version = '2023-05-15'  # Check Azure documentation for the current API version\napi_base = \"\"  # The base URL for your Azure OpenAI resource. e.g. \"https://&lt;your resource name&gt;.openai.azure.com\"\ndeployment_id = \"\"  # The deployment name you chose when you deployed the engine\n</code></pre></p> <p>and set in your configuration file: <pre><code>[config]\nmodel=\"\" # the OpenAI model you've deployed on Azure (e.g. gpt-4o)\nfallback_models=[\"...\"]\n</code></pre></p> <p>Passing custom headers to the underlying LLM Model API can be done by setting extra_headers parameter to litellm.  <pre><code>[litellm]\nextra_headers='{\"projectId\": \"&lt;authorized projectId &gt;\", ...}') #The value of this setting should be a JSON string representing the desired headers, a ValueError is thrown otherwise.\n</code></pre> This enables users to pass authorization tokens or API keys, when routing requests through an API management gateway.</p>"},{"location":"usage-guide/changing_a_model/#ollama","title":"Ollama","text":"<p>You can run models locally through either VLLM or Ollama</p> <p>E.g. to use a new model locally via Ollama, set in <code>.secrets.toml</code> or in a configuration file: <pre><code>[config]\nmodel = \"ollama/qwen2.5-coder:32b\"\nfallback_models=[\"ollama/qwen2.5-coder:32b\"]\ncustom_model_max_tokens=128000 # set the maximal input tokens for the model\nduplicate_examples=true # will duplicate the examples in the prompt, to help the model to generate structured output\n\n[ollama]\napi_base = \"http://localhost:11434\" # or whatever port you're running Ollama on\n</code></pre></p> <p>Local models vs commercial models</p> <p>Qodo Merge is compatible with almost any AI model, but analyzing complex code repositories and pull requests requires a model specifically optimized for code analysis.</p> <p>Commercial models such as GPT-4, Claude Sonnet, and Gemini have demonstrated robust capabilities in generating structured output for code analysis tasks with large input. In contrast, most open-source models currently available (as of January 2025) face challenges with these complex tasks.</p> <p>Based on our testing, local open-source models are suitable for experimentation and learning purposes (mainly for the <code>ask</code> command), but they are not suitable for production-level code analysis tasks.</p> <p>Hence, for production workflows and real-world usage, we recommend using commercial models.</p>"},{"location":"usage-guide/changing_a_model/#hugging-face","title":"Hugging Face","text":"<p>To use a new model with Hugging Face Inference Endpoints, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\nfallback_models=[\"huggingface/meta-llama/Llama-2-7b-chat-hf\"]\ncustom_model_max_tokens=... # set the maximal input tokens for the model\n\n[huggingface] # in .secrets.toml\nkey = ... # your Hugging Face api key\napi_base = ... # the base url for your Hugging Face inference endpoint\n</code></pre> (you can obtain a Llama2 key from here)</p>"},{"location":"usage-guide/changing_a_model/#replicate","title":"Replicate","text":"<p>To use Llama2 model with Replicate, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\nfallback_models=[\"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"]\n[replicate] # in .secrets.toml\nkey = ...\n</code></pre> (you can obtain a Llama2 key from here)</p> <p>Also, review the AiHandler file for instructions on how to set keys for other models.</p>"},{"location":"usage-guide/changing_a_model/#groq","title":"Groq","text":"<p>To use Llama3 model with Groq, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"llama3-70b-8192\"\nfallback_models = [\"groq/llama3-70b-8192\"]\n[groq] # in .secrets.toml\nkey = ... # your Groq api key\n</code></pre> (you can obtain a Groq key from here)</p>"},{"location":"usage-guide/changing_a_model/#vertex-ai","title":"Vertex AI","text":"<p>To use Google's Vertex AI platform and its associated models (chat-bison/codechat-bison) set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"vertex_ai/codechat-bison\"\nfallback_models=\"vertex_ai/codechat-bison\"\n\n[vertexai] # in .secrets.toml\nvertex_project = \"my-google-cloud-project\"\nvertex_location = \"\"\n</code></pre> <p>Your application default credentials will be used for authentication so there is no need to set explicit credentials in most environments.</p> <p>If you do want to set explicit credentials, then you can use the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable set to a path to a json credentials file.</p>"},{"location":"usage-guide/changing_a_model/#google-ai-studio","title":"Google AI Studio","text":"<p>To use Google AI Studio models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config] # in configuration.toml\nmodel=\"google_ai_studio/gemini-1.5-flash\"\nfallback_models=[\"google_ai_studio/gemini-1.5-flash\"]\n\n[google_ai_studio] # in .secrets.toml\ngemini_api_key = \"...\"\n</code></pre> <p>If you don't want to set the API key in the .secrets.toml file, you can set the <code>GOOGLE_AI_STUDIO.GEMINI_API_KEY</code> environment variable.</p>"},{"location":"usage-guide/changing_a_model/#anthropic","title":"Anthropic","text":"<p>To use Anthropic models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config]\nmodel=\"anthropic/claude-3-opus-20240229\"\nfallback_models=[\"anthropic/claude-3-opus-20240229\"]\n</code></pre> <p>And also set the api key in the .secrets.toml file: <pre><code>[anthropic]\nKEY = \"...\"\n</code></pre></p>"},{"location":"usage-guide/changing_a_model/#amazon-bedrock","title":"Amazon Bedrock","text":"<p>To use Amazon Bedrock and its foundational models, add the below configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-sonnet-20240229-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-v2:1\"]\n</code></pre> <p>Note that you have to add access to foundational models before using them. Please refer to this document for more details.</p> <p>If you are using the claude-3 model, please configure the following settings as there are parameters incompatible with claude-3. <pre><code>[litellm]\ndrop_params = true\n</code></pre></p> <p>AWS session is automatically authenticated from your environment, but you can also explicitly set <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> and <code>AWS_REGION_NAME</code> environment variables. Please refer to this document for more details.</p>"},{"location":"usage-guide/changing_a_model/#deepseek","title":"DeepSeek","text":"<p>To use deepseek-chat model with DeepSeek, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"deepseek/deepseek-chat\"\nfallback_models=[\"deepseek/deepseek-chat\"]\n</code></pre> <p>and fill up your key</p> <pre><code>[deepseek] # in .secrets.toml\nkey = ...\n</code></pre> <p>(you can obtain a deepseek-chat key from here)</p>"},{"location":"usage-guide/changing_a_model/#custom-models","title":"Custom models","text":"<p>If the relevant model doesn't appear here, you can still use it as a custom model:</p> <ol> <li>Set the model name in the configuration file: <pre><code>[config]\nmodel=\"custom_model_name\"\nfallback_models=[\"custom_model_name\"]\n</code></pre></li> <li>Set the maximal tokens for the model: <pre><code>[config]\ncustom_model_max_tokens= ...\n</code></pre></li> <li> <p>Go to litellm documentation, find the model you want to use, and set the relevant environment variables.</p> </li> <li> <p>Most reasoning models do not support chat-style inputs (<code>system</code> and <code>user</code> messages) or temperature settings.  To bypass chat templates and temperature controls, set <code>config.custom_reasoning_model = true</code> in your configuration file.</p> </li> </ol>"},{"location":"usage-guide/changing_a_model/#dedicated-parameters","title":"Dedicated parameters","text":""},{"location":"usage-guide/changing_a_model/#openai-models","title":"OpenAI models","text":"<p>[config] reasoning_efffort= = \"medium\" # \"low\", \"medium\", \"high\"</p> <p>With the OpenAI models that support reasoning effort (eg: o3-mini), you can specify its reasoning effort via <code>config</code> section. The default value is <code>medium</code>. You can change it to <code>high</code> or <code>low</code> based on your usage.</p>"},{"location":"usage-guide/configuration_options/","title":"Configuration File","text":"<p>The different tools and sub-tools used by Qodo Merge are adjustable via the configuration file.</p> <p>In addition to general configuration options, each tool has its own configurations. For example, the <code>review</code> tool will use parameters from the pr_reviewer section in the configuration file. See the Tools Guide for a detailed description of the different tools and their configurations.</p> <p>There are three ways to set persistent configurations:</p> <ol> <li>Wiki configuration page \ud83d\udc8e</li> <li>Local configuration file</li> <li>Global configuration file \ud83d\udc8e</li> </ol> <p>In terms of precedence, wiki configurations will override local configurations, and local configurations will override global configurations.</p> <p>Tip1: edit only what you need</p> <p>Your configuration file should be minimal, and edit only the relevant values. Don't copy the entire configuration options, since it can lead to legacy problems when something changes.</p> <p>Tip2: show relevant configurations</p> <p>If you set <code>config.output_relevant_configurations=true</code>, each tool will also output in a collapsible section its relevant configurations. This can be useful for debugging, or getting to know the configurations better.</p>"},{"location":"usage-guide/configuration_options/#wiki-configuration-file","title":"Wiki configuration file \ud83d\udc8e","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>With Qodo Merge, you can set configurations by creating a page called <code>.pr_agent.toml</code> in the wiki of the repo. The advantage of this method is that it allows to set configurations without needing to commit new content to the repo - just edit the wiki page and save.</p> <p></p> <p>Click here to see a short instructional video. We recommend surrounding the configuration content with triple-quotes (or ```toml), to allow better presentation when displayed in the wiki as markdown. An example content:</p> <pre><code>[pr_description]\ngenerate_ai_title=true\n</code></pre> <p>Qodo Merge will know to remove the surrounding quotes when reading the configuration content.</p>"},{"location":"usage-guide/configuration_options/#local-configuration-file","title":"Local configuration file","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket, Azure DevOps</code></p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if you set in <code>.pr_agent.toml</code>:</p> <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\n- instruction a\n- instruction b\n...\n\"\"\"\n</code></pre> <p>Then you can give a list of extra instructions to the <code>review</code> tool.</p>"},{"location":"usage-guide/configuration_options/#global-configuration-file","title":"Global configuration file \ud83d\udc8e","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>If you create a repo called <code>pr-agent-settings</code> in your organization, it's configuration file <code>.pr_agent.toml</code> will be used as a global configuration file for any other repo that belongs to the same organization. Parameters from a local <code>.pr_agent.toml</code> file, in a specific repo, will override the global configuration parameters.</p> <p>For example, in the GitHub organization <code>Codium-ai</code>:</p> <ul> <li> <p>The file <code>https://github.com/Codium-ai/pr-agent-settings/.pr_agent.toml</code>  serves as a global configuration file for all the repos in the GitHub organization <code>Codium-ai</code>.</p> </li> <li> <p>The repo <code>https://github.com/Codium-ai/pr-agent</code> inherits the global configuration file from <code>pr-agent-settings</code>.</p> </li> </ul>"},{"location":"usage-guide/enabling_a_wiki/","title":"Enabling a Wiki","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>For optimal functionality of Qodo Merge, we recommend enabling a wiki for each repository where Qodo Merge is installed. The wiki serves several important purposes:</p> <p>Key Wiki Features: \ud83d\udc8e</p> <ul> <li>Storing a configuration file</li> <li>Defining a <code>best_practices.md</code> file</li> <li>Track accepted suggestions</li> <li>Facilitates learning over time by creating an auto_best_practices.md file</li> </ul> <p>Setup Instructions (GitHub):</p> <p>To enable a wiki for your repository:</p> <ol> <li>Navigate to your repository's main page on GitHub</li> <li>Select \"Settings\" from the top navigation bar</li> <li>Locate the \"Features\" section</li> <li>Enable the \"Wikis\" option by checking the corresponding box</li> <li>Return to your repository's main page</li> <li>Look for the newly added \"Wiki\" tab in the top navigation</li> <li>Initialize your wiki by clicking \"Create the first page\" and saving (this step is important - without creating an initial page, the wiki will not be fully functional)</li> </ol>"},{"location":"usage-guide/enabling_a_wiki/#why-wiki","title":"Why Wiki?","text":"<ul> <li>Your code (and its derivatives, including accepted code suggestions) is yours. Qodo Merge will never store it on external servers.</li> <li>Repository changes typically require pull requests, which create overhead and are time-consuming. This process is too cumbersome for auto data aggregation, and is not very convenient even for managing frequently updated content like configuration files and best practices.</li> <li>A repository wiki page provides an ideal balance:<ul> <li>It lives within your repository, making it suitable for code-related documentation</li> <li>It enables quick updates without the overhead of pull requests</li> <li>It maintains full Git version control, allowing you to track changes over time.</li> </ul> </li> </ul>"},{"location":"usage-guide/introduction/","title":"Introduction","text":"<p>After installation, there are three basic ways to invoke Qodo Merge:</p> <ol> <li>Locally running a CLI command</li> <li>Online usage - by commenting on a PR</li> <li>Enabling Qodo Merge tools to run automatically when a new PR is opened</li> </ol> <p>Specifically, CLI commands can be issued by invoking a pre-built docker image, or by invoking a locally cloned repo.</p> <p>For online usage, you will need to setup either a GitHub App or a GitHub Action (GitHub), a GitLab webhook (GitLab), or a BitBucket App (BitBucket). These platforms also enable to run Qodo Merge specific tools automatically when a new PR is opened, or on each push to a branch.</p>"},{"location":"usage-guide/mail_notifications/","title":"Managing Mail Notifications","text":"<p>Unfortunately, it is not possible in GitHub to disable mail notifications from a specific user. If you are subscribed to notifications for a repo with Qodo Merge, we recommend turning off notifications for PR comments, to avoid lengthy emails:</p> <p></p> <p>As an alternative, you can filter in your mail provider the notifications specifically from the Qodo Merge bot, see how.</p> <p></p> <p>Another option to reduce the mail overload, yet still receive notifications on Qodo Merge tools, is to disable the help collapsible section in Qodo Merge bot comments. This can done by setting <code>enable_help_text=false</code> for the relevant tool in the configuration file. For example, to disable the help text for the <code>pr_reviewer</code> tool, set: <pre><code>[pr_reviewer]\nenable_help_text = false\n</code></pre></p>"},{"location":"usage-guide/qodo_merge_models/","title":"\ud83d\udc8e Qodo Merge Models","text":"<p>The default models used by Qodo Merge are a combination of Claude-3.5-sonnet and  OpenAI's GPT-4 models.</p>"},{"location":"usage-guide/qodo_merge_models/#selecting-a-specific-model","title":"Selecting a Specific Model","text":"<p>Users can configure Qodo Merge to use a specific model by editing the configuration file. The models supported by Qodo Merge are:</p> <ul> <li><code>claude-3-5-sonnet</code></li> <li><code>gpt-4o</code></li> <li><code>o3-mini</code></li> </ul> <p>To restrict Qodo Merge to using only <code>Claude-3.5-sonnet</code>, add this setting:</p> <pre><code>[config]\nmodel=\"claude-3-5-sonnet\"\n</code></pre> <p>To restrict Qodo Merge to using only <code>GPT-4o</code>, add this setting: <pre><code>[config]\nmodel=\"gpt-4o\"\n</code></pre></p> <p>To restrict Qodo Merge to using only <code>o3-mini</code>, add this setting: <pre><code>[config]\nmodel=\"o3-mini\"\n</code></pre></p>"}]}