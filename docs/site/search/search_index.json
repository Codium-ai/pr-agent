{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#features-table","title":"Features table","text":""},{"location":"#features-description","title":"Features description","text":""},{"location":"#examples-and-results","title":"Examples and results","text":""},{"location":"#how-it-works","title":"How it works","text":""},{"location":"#pr-agent-pro","title":"PR-Agent Pro","text":""},{"location":"#new-and-updates","title":"New and updates","text":""},{"location":"#benefits-of-pr-agent","title":"Benefits of PR-Agent","text":"<ul> <li>Quick and affordable answer retrieval (~30 seconds). Each tool (review, improve, ask, ...) has a single GPT-4 call, no more.</li> <li>Any PR size can be effectively used in as a context thanks uur compression strategy.</li> <li>Each command is modular and can be controlled with shared configuration file. </li> <li>Multiple git providers GitHub, Gitlab, Bitbucket are supported.</li> <li>Multiple platforms to use the commands (CLI, GitHub Action, GitHub App, Docker, ...) are supported.</li> <li>Multiple models (GPT-4, GPT-3.5, Anthropic, Cohere, Llama2) are supported.</li> </ul>"},{"location":"#features-support","title":"Features support","text":"<p>PR-Agent offers extensive pull request functionalities across various git providers.</p> <p>\ud83d\udc8e marks a feature available only in PR-Agent Pro</p> GitHub Gitlab Bitbucket TOOLS Review \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Incremental \u2714\ufe0f SOC2 Compliance \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Ask \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Describe \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Inline file summary \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Improve \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2b91 Extended \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Custom Suggestions \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Reflect and Review \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Update CHANGELOG.md \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Find Similar Issue \u2714\ufe0f Add PR Documentation \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Generate Custom Labels \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f Analyze PR Components \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f USAGE CLI \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f App / webhook \u2714\ufe0f \u2714\ufe0f Tagging bot \u2714\ufe0f Actions \u2714\ufe0f CORE PR compression \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Repo language prioritization \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Adaptive and token-aware file patch fitting \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Multiple models support \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Incremental PR review \u2714\ufe0f Static code analysis \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Global configuration \ud83d\udc8e \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f"},{"location":"core-abilities/","title":"Core Abilities","text":"<p>Do we want to add something here?</p>"},{"location":"core-abilities/pr-compression/","title":"PR Compression Strategy","text":"<p>There are two scenarios:</p> <ol> <li>The PR is small enough to fit in a single prompt (including system and user prompt)</li> <li>The PR is too large to fit in a single prompt (including system and user prompt)</li> </ol> <p>For both scenarios, we first use the following strategy</p>"},{"location":"core-abilities/pr-compression/#repo-language-prioritization-strategy","title":"Repo language prioritization strategy","text":"<p>We prioritize the languages of the repo based on the following criteria:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>Given the main languages used in the repo</li> <li>We sort the PR files by the most common languages in the repo (in descending order): </li> <li><code>[[file.py, file2.py],[file3.js, file4.jsx],[readme.md]]</code></li> </ol>"},{"location":"core-abilities/pr-compression/#small-pr","title":"Small PR","text":"<p>In this case, we can fit the entire PR in a single prompt: 1. Exclude binary files and non code files (e.g. images, pdfs, etc) 2. We Expand the surrounding context of each patch to 3 lines above and below the patch</p>"},{"location":"core-abilities/pr-compression/#large-pr","title":"Large PR","text":""},{"location":"core-abilities/pr-compression/#motivation","title":"Motivation","text":"<p>Pull Requests can be very long and contain a lot of information with varying degree of relevance to the pr-agent. We want to be able to pack as much information as possible in a single LMM prompt, while keeping the information relevant to the pr-agent.</p>"},{"location":"core-abilities/pr-compression/#compression-strategy","title":"Compression strategy","text":"<p>We prioritize additions over deletions:  - Combine all deleted files into a single list (<code>deleted files</code>)  - File patches are a list of hunks, remove all hunks of type deletion-only from the hunks in the file patch</p>"},{"location":"core-abilities/pr-compression/#adaptive-and-token-aware-file-patch-fitting","title":"Adaptive and token-aware file patch fitting","text":"<p>We use tiktoken to tokenize the patches after the modifications described above, and we use the following strategy to fit the patches into the prompt:</p> <ol> <li>Within each language we sort the files by the number of tokens in the file (in descending order):<ul> <li><code>[[file2.py, file.py],[file4.jsx, file3.js],[readme.md]]</code></li> </ul> </li> <li>Iterate through the patches in the order described above</li> <li>Add the patches to the prompt until the prompt reaches a certain buffer from the max token length</li> <li>If there are still patches left, add the remaining patches as a list called <code>other modified files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> <li>If we haven't reached the max token length, add the <code>deleted files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> </ol>"},{"location":"core-abilities/pr-compression/#example","title":"Example","text":""},{"location":"installation/","title":"Installation","text":"<p>If you choose to host you own PR-Agent, you first need to acquire two tokens:</p> <ol> <li>An OpenAI key from here, with access to GPT-4 (or a key for other models, if you prefer).</li> <li>A GitHub\\GitLab\\BitBucket personal access token (classic), with the repo scope. [GitHub from here]</li> </ol> <p>There are several ways to use self-hosted PR-Agent:</p> <ul> <li>Locally</li> <li>GitHub</li> <li>GitLab</li> <li>BitBucket</li> <li>Azure DevOps</li> </ul> <p>Note that PR-Agent Pro \ud83d\udc8e, an app for GitHub\\GitLab\\BitBucket hosted by CodiumAI, is also available.   With PR-Agent Pro Installation is as simple as signing up and adding the PR-Agent app to your relevant repo.</p>"},{"location":"installation/azure/","title":"Azure","text":""},{"location":"installation/azure/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\nuse_repo_settings_file=false\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in experation date, and will use the user identity for API calls.  Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create seperate ADO user identity (via AAD) to the agent.</p> <p>If PAT was choosen, you can assign the value in .secrets.toml.  If DefaultAzureCredential was choosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly,  or use managed identity/az cli (for local develpment) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"installation/azure/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To trigger from an Azure webhook, you need to manually add a webhook.  Use the \"Pull request created\" type to trigger a review, or \"Pull request commented on\" to trigger any supported comment with /  comment on the relevant PR. Note that for the \"Pull request commented on\" trigger, only API v2.0 is supported. <p>For webhook security, create a sporadic username/password pair and configure the webhook username and password on both the server and Azure DevOps webhook. These will be sent as basic Auth data by the webhook with each request: <pre><code>[azure_devops_server]\nwebhook_username = \"&lt;basic auth user&gt;\"\nwebhook_password = \"&lt;basic auth password&gt;\"\n</code></pre></p> <p> Ensure that the webhook endpoint is only accessible over HTTPS to mitigate the risk of credential interception when using basic authentication.</p>"},{"location":"installation/bitbucket/","title":"BitBucket","text":""},{"location":"installation/bitbucket/#run-as-a-bitbucket-pipeline","title":"Run as a Bitbucket Pipeline","text":"<p>You can use the Bitbucket Pipeline system to run PR-Agent on every pull request open or update.</p> <ol> <li>Add the following file in your repository bitbucket_pipelines.yml</li> </ol> <pre><code>pipelines:\n    pull-requests:\n      '**':\n        - step:\n            name: PR Agent Review\n            image: python:3.10\n            services:\n              - docker\n            script:\n              - docker run -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=https://bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG/pull-requests/$BITBUCKET_PR_ID review\n</code></pre> <ol> <li>Add the following secure variables to your repository under Repository settings &gt; Pipelines &gt; Repository variables. OPENAI_API_KEY: <code>&lt;your key&gt;</code> BITBUCKET_BEARER_TOKEN: <code>&lt;your token&gt;</code></li> </ol> <p>You can get a Bitbucket token for your repository by following Repository Settings -&gt; Security -&gt; Access Tokens.</p> <p>Note that comments on a PR are not supported in Bitbucket Pipeline.</p>"},{"location":"installation/bitbucket/#run-using-codiumai-hosted-bitbucket-app","title":"Run using CodiumAI-hosted Bitbucket app","text":"<p>Please contact support@codium.ai or visit CodiumAI pricing page if you're interested in a hosted BitBucket app solution that provides full functionality including PR reviews and comment handling. It's based on the bitbucket_app.py implementation.</p>"},{"location":"installation/bitbucket/#bitbucket-server-and-data-center","title":"Bitbucket Server and Data Center","text":"<p>Login into your on-prem instance of Bitbucket with your service account username and password. Navigate to <code>Manage account</code>, <code>HTTP Access tokens</code>, <code>Create Token</code>. Generate the token and add it to .secret.toml under <code>bitbucket_server</code> section</p> <pre><code>[bitbucket_server]\nbearer_token = \"&lt;your key&gt;\"\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-cli","title":"Run it as CLI","text":"<p>Modify <code>configuration.toml</code>:</p> <pre><code>git_provider=\"bitbucket_server\"\n</code></pre> <p>and pass the Pull request URL: <pre><code>python cli.py --pr_url https://git.onpreminstanceofbitbucket.com/projects/PROJECT/repos/REPO/pull-requests/1 review\n</code></pre></p>"},{"location":"installation/bitbucket/#run-it-as-service","title":"Run it as service","text":"<p>To run pr-agent as webhook, build the docker image: <pre><code>docker build . -t codiumai/pr-agent:bitbucket_server_webhook --target bitbucket_server_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:bitbucket_server_webhook  # Push to your Docker repository\n</code></pre></p> <p>Navigate to <code>Projects</code> or <code>Repositories</code>, <code>Settings</code>, <code>Webhooks</code>, <code>Create Webhook</code>. Fill the name and URL, Authentication None select the Pull Request Opened checkbox to receive that event as webhook.</p> <p>The URL should end with <code>/webhook</code>, for example: https://domain.com/webhook</p>"},{"location":"installation/github/","title":"GitHub","text":""},{"location":"installation/github/#run-as-a-github-action","title":"Run as a GitHub Action","text":"<p>You can use our pre-built Github Action Docker image to run PR-Agent as a Github Action.</p> <ol> <li>Add the following file to your repository under <code>.github/workflows/pr_agent.yml</code>:</li> </ol> <p><pre><code>on:\n  pull_request:\n  issue_comment:\njobs:\n  pr_agent_job:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: Codium-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> ** if you want to pin your action to a specific release (v0.7 for example) for stability reasons, use: <pre><code>on:\n  pull_request:\n  issue_comment:\n\njobs:\n  pr_agent_job:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: Codium-ai/pr-agent@v0.7\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> 2. Add the following secret to your repository under <code>Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret &gt; Add secret</code>:</p> <pre><code>Name = OPENAI_KEY\nSecret = &lt;your key&gt;\n</code></pre> <p>The GITHUB_TOKEN secret is automatically created by GitHub.</p> <ol> <li> <p>Merge this change to your main branch. When you open your next PR, you should see a comment from <code>github-actions</code> bot with a review of your PR, and instructions on how to use the rest of the tools.</p> </li> <li> <p>You may configure PR-Agent by adding environment variables under the env section corresponding to any configurable property in the configuration file. Some examples: <pre><code>      env:\n        # ... previous environment values\n        OPENAI.ORG: \"&lt;Your organization name under your OpenAI account&gt;\"\n        PR_REVIEWER.REQUIRE_TESTS_REVIEW: \"false\" # Disable tests review\n        PR_CODE_SUGGESTIONS.NUM_CODE_SUGGESTIONS: 6 # Increase number of code suggestions\n</code></pre></p> </li> </ol>"},{"location":"installation/github/#run-as-a-polling-server","title":"Run as a polling server","text":"<p>Request reviews by tagging your GitHub user on a PR</p> <p>Follow steps 1-3 of the GitHub Action setup.</p> <p>Run the following command to start the server:</p> <pre><code>python pr_agent/servers/github_polling.py\n</code></pre>"},{"location":"installation/github/#run-as-a-github-app","title":"Run as a GitHub App","text":"<p>Allowing you to automate the review process on your private or public repositories.</p> <ol> <li> <p>Create a GitHub App from the Github Developer Portal.</p> </li> <li> <p>Set the following permissions:</p> <ul> <li>Pull requests: Read &amp; write</li> <li>Issue comment: Read &amp; write</li> <li>Metadata: Read-only</li> <li>Contents: Read-only</li> </ul> </li> <li> <p>Set the following events:</p> <ul> <li>Issue comment</li> <li>Pull request</li> <li>Push (if you need to enable triggering on PR update)</li> </ul> </li> <li> <p>Generate a random secret for your app, and save it for later. For example, you can use:</p> </li> </ol> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li> <p>Acquire the following pieces of information from your app's settings page:</p> </li> <li> <p>App private key (click \"Generate a private key\" and save the file)</p> </li> <li> <p>App ID</p> </li> <li> <p>Clone this repository:</p> </li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Copy the secrets template file and fill in the following:     <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre></li> <li>Your OpenAI key.</li> <li>Copy your app's private key to the private_key field.</li> <li>Copy your app's ID to the app_id field.</li> <li>Copy your app's webhook secret to the webhook_secret field.</li> <li>Set deployment_type to 'app' in configuration.toml</li> </ol> <p>The .secrets.toml file is not copied to the Docker image by default, and is only used for local development. If you want to use the .secrets.toml file in your Docker image, you can add remove it from the .dockerignore file. In most production environments, you would inject the secrets file as environment variables or as mounted volumes. For example, in order to inject a secrets file as a volume in a Kubernetes environment you can update your pod spec to include the following, assuming you have a secret named <code>pr-agent-settings</code> with a key named <code>.secrets.toml</code>: <pre><code>       volumes:\n        - name: settings-volume\n          secret:\n            secretName: pr-agent-settings\n// ...\n       containers:\n// ...\n          volumeMounts:\n            - mountPath: /app/pr_agent/settings_prod\n              name: settings-volume\n</code></pre></p> <p>Another option is to set the secrets as environment variables in your deployment environment, for example <code>OPENAI.KEY</code> and <code>GITHUB.USER_TOKEN</code>.</p> <ol> <li>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</li> </ol> <pre><code>docker build . -t codiumai/pr-agent:github_app --target github_app -f docker/Dockerfile\ndocker push codiumai/pr-agent:github_app  # Push to your Docker repository\n</code></pre> <ol> <li> <p>Host the app using a server, serverless function, or container environment. Alternatively, for development and    debugging, you may use tools like smee.io to forward webhooks to your local machine.     You can check Deploy as a Lambda Function</p> </li> <li> <p>Go back to your app's settings, and set the following:</p> </li> <li> <p>Webhook URL: The URL of your app's server or the URL of the smee.io channel.</p> </li> <li> <p>Webhook secret: The secret you generated earlier.</p> </li> <li> <p>Install the app by navigating to the \"Install App\" tab and selecting your desired repositories.</p> </li> </ol> <p>Note: When running PR-Agent from GitHub App, the default configuration file (configuration.toml) will be loaded. However, you can override the default tool parameters by uploading a local configuration file <code>.pr_agent.toml</code> For more information please check out the USAGE GUIDE</p>"},{"location":"installation/github/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<ol> <li>Follow steps 1-5 of Method 5.</li> <li>Build a docker image that can be used as a lambda function     <code>shell     docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:serverless -f docker/Dockerfile.lambda</code></li> <li>Push image to ECR     <pre><code>docker tag codiumai/pr-agent:serverless &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\n</code></pre></li> <li>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Method 5 with the function url as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/api/v1/github_webhooks</code></li> </ol>"},{"location":"installation/github/#aws-codecommit-setup","title":"AWS CodeCommit Setup","text":"<p>Not all features have been added to CodeCommit yet.  As of right now, CodeCommit has been implemented to run the pr-agent CLI on the command line, using AWS credentials stored in environment variables.  (More features will be added in the future.)  The following is a set of instructions to have pr-agent do a review of your CodeCommit pull request from the command line:</p> <ol> <li>Create an IAM user that you will use to read CodeCommit pull requests and post comments<ul> <li>Note: That user should have CLI access only, not Console access</li> </ul> </li> <li>Add IAM permissions to that user, to allow access to CodeCommit (see IAM Role example below)</li> <li>Generate an Access Key for your IAM user</li> <li>Set the Access Key and Secret using environment variables (see Access Key example below)</li> <li>Set the <code>git_provider</code> value to <code>codecommit</code> in the <code>pr_agent/settings/configuration.toml</code> settings file</li> <li>Set the <code>PYTHONPATH</code> to include your <code>pr-agent</code> project directory<ul> <li>Option A: Add <code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent</code> to your <code>.env</code> file</li> <li>Option B: Set <code>PYTHONPATH</code> and run the CLI in one command, for example:<ul> <li><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent python pr_agent/cli.py [--ARGS]</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"installation/github/#aws-codecommit-iam-role-example","title":"AWS CodeCommit IAM Role Example","text":"<p>Example IAM permissions to that user to allow access to CodeCommit:</p> <ul> <li>Note: The following is a working example of IAM permissions that has read access to the repositories and write access to allow posting comments</li> <li>Note: If you only want pr-agent to review your pull requests, you can tighten the IAM permissions further, however this IAM example will work, and allow the pr-agent to post comments to the PR</li> <li>Note: You may want to replace the <code>\"Resource\": \"*\"</code> with your list of repos, to limit access to only those repos</li> </ul> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codecommit:BatchDescribe*\",\n                \"codecommit:BatchGet*\",\n                \"codecommit:Describe*\",\n                \"codecommit:EvaluatePullRequestApprovalRules\",\n                \"codecommit:Get*\",\n                \"codecommit:List*\",\n                \"codecommit:PostComment*\",\n                \"codecommit:PutCommentReaction\",\n                \"codecommit:UpdatePullRequestDescription\",\n                \"codecommit:UpdatePullRequestTitle\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"installation/github/#aws-codecommit-access-key-and-secret","title":"AWS CodeCommit Access Key and Secret","text":"<p>Example setting the Access Key and Secret using environment variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"XXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"XXXXXXXXXXXXXXXX\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre>"},{"location":"installation/github/#aws-codecommit-cli-example","title":"AWS CodeCommit CLI Example","text":"<p>After you set up AWS CodeCommit using the instructions above, here is an example CLI run that tells pr-agent to review a given pull request. (Replace your specific PYTHONPATH and PR URL in the example)</p> <pre><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent\" python pr_agent/cli.py \\\n  --pr_url https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/MY_REPO_NAME/pull-requests/321 \\\n  review\n</code></pre>"},{"location":"installation/gitlab/","title":"GitLab","text":""},{"location":"installation/gitlab/#run-a-gitlab-webhook-server","title":"Run a GitLab webhook server","text":"<ol> <li>From the GitLab workspace or group, create an access token. Enable the \"api\" scope only.</li> <li>Generate a random secret for your app, and save it for later. For example, you can use:</li> </ol> <p><pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> 3. Follow the instructions to build the Docker image, setup a secrets file and deploy on your own server from Method 5 steps 4-7. 4. In the secrets file, fill in the following:     - Your OpenAI key.     - In the [gitlab] section, fill in personal_access_token and shared_secret. The access token can be a personal access token, or a group or project access token.     - Set deployment_type to 'gitlab' in configuration.toml 5. Create a webhook in GitLab. Set the URL to the URL of your app's server. Set the secret token to the generated secret from step 2. In the \"Trigger\" section, check the \u2018comments\u2019 and \u2018merge request events\u2019 boxes. 6. Test your installation by opening a merge request or commenting or a merge request using one of CodiumAI's commands.</p>"},{"location":"installation/locally/","title":"Locally","text":""},{"location":"installation/locally/#use-docker-image-no-installation-required","title":"Use Docker image (no installation required)","text":"<p>A list of the relevant tools can be found in the tools guide.</p> <p>To invoke a tool (for example <code>review</code>), you can run directly from the Docker image. Here's how:</p> <ul> <li> <p>For GitHub: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e GITHUB.USER_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> </li> <li> <p>For GitLab: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> </li> </ul> <p>Note: If you have a dedicated GitLab instance, you need to specify the custom url as variable: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; -e GITLAB.URL=&lt;your gitlab instance url&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> <ul> <li>For BitBucket: <pre><code>docker run --rm -it -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=&lt;pr_url&gt; review\n</code></pre></li> </ul> <p>For other git providers, update CONFIG.GIT_PROVIDER accordingly, and check the <code>pr_agent/settings/.secrets_template.toml</code> file for the environment variables expected names and values.</p> <p>If you want to ensure you're running a specific version of the Docker image, consider using the image's digest: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e GITHUB.USER_TOKEN=&lt;your token&gt; codiumai/pr-agent@sha256:71b5ee15df59c745d352d84752d01561ba64b6d51327f97d46152f0c58a5f678 --pr_url &lt;pr_url&gt; review\n</code></pre></p> <p>Or you can run a specific released versions of pr-agent, for example: <pre><code>codiumai/pr-agent@v0.9\n</code></pre></p>"},{"location":"installation/locally/#run-from-source","title":"Run from source","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Navigate to the <code>/pr-agent</code> folder and install the requirements in your favorite virtual environment:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>Note: If you get an error related to Rust in the dependency installation then make sure Rust is installed and in your <code>PATH</code>, instructions: https://rustup.rs</p> <ol> <li>Copy the secrets template file and fill in your OpenAI key and your GitHub user token:</li> </ol> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\nchmod 600 pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ol> <li>Run the cli.py script:</li> </ol> <pre><code>python3 -m pr_agent.cli --pr_url &lt;pr_url&gt; review\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; ask &lt;your question&gt;\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; describe\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; improve\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; add_docs\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; generate_labels\npython3 -m pr_agent.cli --issue_url &lt;issue_url&gt; similar_issue\n...\n</code></pre> <p>[Optional]\u00a0Add the pr_agent folder to your PYTHONPATH <pre><code>export PYTHONPATH=$PYTHONPATH:&lt;PATH to pr_agent folder&gt;\n</code></pre></p>"},{"location":"tools/","title":"Tools","text":"<p>Here is a list of PR-Agent tools, each with a dedicated page that explains how to use it:</p> Tool Description PR Description (<code>/describe</code>) Automatically generating PR description - title, type, summary, code walkthrough and labels PR Review (<code>/review</code>) Adjustable feedback about the PR, possible issues, security concerns, review effort and more Code Suggestions (<code>/improve</code>) Code suggestions for improving the PR Question Answering (<code>/ask ...</code>) Answering free-text questions about the PR, or on specific code lines Update Changelog (<code>/update_changelog</code>) Automatically updating the CHANGELOG.md file with the PR changes Find Similar Issue (<code>/similar_issue</code>) Automatically retrieves and presents similar issues \ud83d\udc8e Add Documentation (<code>/add_docs</code>) Generates documentation to methods/functions/classes that changed in the PR \ud83d\udc8e Generate Custom Labels (<code>/generate_labels</code>) Generates custom labels for the PR, based on specific guidelines defined by the user \ud83d\udc8e Analyze (<code>/analyze</code>) Identify code components that changed in the PR, and enables to interactively generate tests, docs, and code suggestions for each component \ud83d\udc8e Custom Suggestions (<code>/custom_suggestions</code>) Automatically generates custom suggestions for improving the PR code, based on specific guidelines defined by the user \ud83d\udc8e Generate Tests (<code>/test component_name</code>) Automatically generates unit tests for a selected component, based on the PR code changes \ud83d\udc8e CI Feedback (<code>/checks ci_job</code>) Automatically generates feedback and analysis for a failed CI job <p>Note that the tools marked with \ud83d\udc8e are available only for PR-Agent Pro users.</p>"},{"location":"tools/analyze/","title":"\ud83d\udc8e Analyze","text":""},{"location":"tools/analyze/#overview","title":"Overview","text":"<p>The <code>analyze</code> tool combines static code analysis with LLM capabilities to provide a comprehensive analysis of the PR code changes.</p> <p>The tool scans the PR code changes, find the code components (methods, functions, classes) that changed, and summarizes the changes in each component.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/analyze\n</code></pre></p>"},{"location":"tools/analyze/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p></p> <p></p> <p>Notes</p> <ul> <li>Language that are currently supported: Python, Java, C++, JavaScript, TypeScript.</li> </ul>"},{"location":"tools/ask/","title":"Ask","text":""},{"location":"tools/ask/#overview","title":"Overview","text":"<p>The <code>ask</code> tool answers questions about the PR, based on the PR code changes. Make sure to be specific and clear in your questions. It can be invoked manually by commenting on any PR: <pre><code>/ask \"...\"\n</code></pre> For example:</p> <p></p> <p></p>"},{"location":"tools/ask/#ask-lines","title":"Ask lines","text":"<p>You can run <code>/ask</code> on specific lines of code in the PR from the PR's diff view. The tool will answer questions based on the code changes in the selected lines. - Click on the '+' sign next to the line number to select the line. - To select multiple lines, click on the '+' sign of the first line and then hold and drag to select the rest of the lines.  - write <code>/ask \"...\"</code> in the comment box and press <code>Add single comment</code> button.</p> <p></p> <p>Note that the tool does not have \"memory\" of previous questions, and answers each question independently.</p>"},{"location":"tools/ci_feedback/","title":"\ud83d\udc8e CI Feedback","text":""},{"location":"tools/ci_feedback/#overview","title":"Overview","text":"<p>The CI feedback tool (<code>/checks)</code> automatically triggers when a PR has a failed check. The tool analyzes the failed checks and provides several feedbacks:</p> <ul> <li>Failed stage</li> <li>Failed test name</li> <li>Failure summary</li> <li>Relevant error logs</li> </ul> <p>  \u2192  </p> <p>In addition to being automatically triggered, the tool can also be invoked manually by commenting on a PR: <pre><code>/checks \"https://github.com/{repo_name}/actions/runs/{run_number}/job/{job_number}\"\n</code></pre> where <code>{repo_name}</code> is the name of the repository, <code>{run_number}</code> is the run number of the failed check, and <code>{job_number}</code> is the job number of the failed check.</p>"},{"location":"tools/ci_feedback/#configuration-options","title":"Configuration options","text":"<ul> <li><code>enable_auto_checks_feedback</code> - if set to true, the tool will automatically provide feedback when a check is failed. Default is true.</li> <li><code>excluded_checks_list</code> - a list of checks to exclude from the feedback, for example: [\"check1\", \"check2\"]. Default is an empty list.</li> <li><code>persistent_comment</code> - if set to true, the tool will overwrite a previous checks comment with the new feedback. Default is true.</li> <li><code>enable_help_text=true</code> - if set to true, the tool will provide a help message when a user comments \"/checks\" on a PR. Default is true.</li> </ul>"},{"location":"tools/custom_labels/","title":"\ud83d\udc8e Custom Labels","text":""},{"location":"tools/custom_labels/#overview","title":"Overview","text":"<p>The <code>generate_labels</code> tool scans the PR code changes, and given a list of labels and their descriptions, it automatically suggests labels that match the PR code changes.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/generate_labels\n</code></pre> For example:</p> <p>If we wish to add detect changes to SQL queries in a given PR, we can add the following custom label along with its description:</p> <p></p> <p>When running the <code>generate_labels</code> tool on a PR that includes changes in SQL queries, it will automatically suggest the custom label:</p> <p></p> <p>Note that in addition to the dedicated tool <code>generate_labels</code>, the custom labels will also be used by the <code>describe</code> tool.</p>"},{"location":"tools/custom_labels/#how-to-enable-custom-labels","title":"How to enable custom labels","text":"<p>There are 3 ways to enable custom labels:</p>"},{"location":"tools/custom_labels/#1-cli-local-configuration-file","title":"1. CLI (local configuration file)","text":"<p>When working from CLI, you need to apply the configuration changes to the custom_labels file:</p>"},{"location":"tools/custom_labels/#2-repo-configuration-file","title":"2. Repo configuration file","text":"<p>To enable custom labels, you need to apply the configuration changes to the local <code>.pr_agent.toml</code> file in you repository.</p>"},{"location":"tools/custom_labels/#3-handle-custom-labels-from-the-repos-labels-page","title":"3. Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>This feature is available only in PR-Agent Pro </p> <ul> <li>GitHub : <code>https://github.com/{owner}/{repo}/labels</code>, or click on the \"Labels\" tab in the issues or PRs page.</li> <li>GitLab : <code>https://gitlab.com/{owner}/{repo}/-/labels</code>, or click on \"Manage\" -&gt; \"Labels\" on the left menu.</li> </ul> <p>b. Add/edit the custom labels. It should be formatted as follows: * Label name: The name of the custom label. * Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>. The description should be comprehensive and detailed, indicating when to add the desired label. </p> <p>c. Now the custom labels will be included in the <code>generate_labels</code> tool.</p> <p>This feature is supported in GitHub and GitLab.</p>"},{"location":"tools/custom_labels/#configuration-options","title":"Configuration options","text":"<ul> <li>Change <code>enable_custom_labels</code> to True: This will turn off the default labels and enable the custom labels provided in the custom_labels.toml file.</li> <li>Add the custom labels. It should be formatted as follows:</li> </ul> <pre><code>[config]\nenable_custom_labels=true\n\n[custom_labels.\"Custom Label Name\"]\ndescription = \"Description of when AI should suggest this label\"\n\n[custom_labels.\"Custom Label 2\"]\ndescription = \"Description of when AI should suggest this label 2\"\n</code></pre>"},{"location":"tools/custom_suggestions/","title":"\ud83d\udc8e Custom Suggestions","text":""},{"location":"tools/custom_suggestions/#overview","title":"Overview","text":"<p>The <code>custom_suggestions</code> tool scans the PR code changes, and automatically generates custom suggestions for improving the PR code. It shares similarities with the <code>improve</code> tool, but with one main difference: the <code>custom_suggestions</code> tool will only propose suggestions that follow specific guidelines defined by the prompt in: <code>pr_custom_suggestions.prompt</code> configuration.</p> <p>The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on a PR.</p> <p>When commenting, use the following template:</p> <pre><code>/custom_suggestions --pr_custom_suggestions.prompt=\"The suggestions should focus only on the following:\\n-...\\n-...\\n-...\"\n</code></pre> <p>With a configuration file, use the following template:</p> <p><pre><code>[pr_custom_suggestions]\nprompt=\"\"\"\\\nThe suggestions should focus only on the following:\n-...\n-...\n-...\n\"\"\"\n</code></pre> Using a configuration file is recommended, since it allows to use multi-line instructions.</p> <p>Don't forget - with this tool, you are the prompter. Be specific, clear, and concise in the instructions. Specify relevant aspects that you want the model to focus on. \\ You might benefit from several trial-and-error iterations, until you get the correct prompt for your use case.</p>"},{"location":"tools/custom_suggestions/#example-usage","title":"Example usage","text":"<p>Here is an example of a possible prompt: <pre><code>[pr_custom_suggestions]\nprompt=\"\"\"\\\nThe suggestions should focus only on the following:\n- look for edge cases when implementing a new function\n- make sure every variable has a meaningful name\n- make sure the code is efficient\n\"\"\"\n</code></pre></p> <p>The instructions above are just an example. We want to emphasize that the prompt should be specific and clear, and be tailored to the needs of your project.</p> <p>Results obtained with the prompt above:</p> <p></p> <p></p>"},{"location":"tools/custom_suggestions/#configuration-options","title":"Configuration options","text":"<p><code>prompt</code>: the prompt for the tool. It should be a multi-line string.</p> <p><code>num_code_suggestions</code>: number of code suggestions provided by the 'custom_suggestions' tool. Default is 4.</p> <p><code>enable_help_text</code>: if set to true, the tool will display a help text in the comment. Default is true.</p>"},{"location":"tools/describe/","title":"Describe","text":""},{"location":"tools/describe/#overview","title":"Overview","text":"<p>The <code>describe</code> tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels.</p> <p>The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/describe\n</code></pre> For example:</p> <p></p> <p></p>"},{"location":"tools/describe/#configuration-options","title":"Configuration options","text":"<p>To edit configurations related to the describe tool (<code>pr_description</code> section), use the following template: <pre><code>/describe --pr_description.some_config1=... --pr_description.some_config2=...\n</code></pre></p>"},{"location":"tools/describe/#possible-configurations","title":"Possible configurations:","text":"<ul> <li> <p><code>publish_labels</code>: if set to true, the tool will publish the labels to the PR. Default is true.</p> </li> <li> <p><code>publish_description_as_comment</code>: if set to true, the tool will publish the description as a comment to the PR. If false, it will overwrite the origianl description. Default is false.</p> </li> <li> <p><code>add_original_user_description</code>: if set to true, the tool will add the original user description to the generated description. Default is true.</p> </li> <li> <p><code>keep_original_user_title</code>: if set to true, the tool will keep the original PR title, and won't change it. Default is true.</p> </li> <li> <p><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</p> </li> <li> <p>To enable <code>custom labels</code>, apply the configuration changes described here</p> </li> <li> <p><code>enable_pr_type</code>: if set to false, it will not show the <code>PR type</code> as a text value in the description content. Default is true.</p> </li> <li> <p><code>final_update_message</code>: if set to true, it will add a comment message <code>PR Description updated to latest commit...</code> after finishing calling <code>/describe</code>. Default is true.</p> </li> <li> <p><code>enable_semantic_files_types</code>: if set to true, \"Changes walkthrough\" section will be generated. Default is true.</p> </li> <li><code>collapsible_file_list</code>: if set to true, the file list in the \"Changes walkthrough\" section will be collapsible. If set to \"adaptive\", the file list will be collapsible only if there are more than 8 files. Default is \"adaptive\".</li> </ul>"},{"location":"tools/describe/#inline-file-summary","title":"Inline file summary \ud83d\udc8e","text":"<p>This feature is available only in PR-Agent Pro</p> <p>This feature will enable you to quickly understand the changes in each file while reviewing the code changes (diff view).</p> <p>To add the walkthrough table to the \"Files changed\" tab, you can click on the checkbox that appears PR Description status message below the main PR Description:</p> <p></p> <p>If you prefer to have the file summaries appear in the \"Files changed\" tab on every PR, change the <code>pr_description.inline_file_summary</code> parameter in the configuration file, possible values are:</p> <ul> <li> <p><code>'table'</code>: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab. </p> </li> <li> <p><code>true</code>: A collapsable file comment with changes title and a changes summary for each file in the PR. </p> </li> <li> <p><code>false</code> (<code>default</code>): File changes walkthrough will be added only to the \"Conversation\" tab.</p> </li> </ul> <p>Note that this feature is currently available only for GitHub.</p>"},{"location":"tools/describe/#handle-custom-labels-from-the-repos-labels-page","title":"Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>This feature is available only in PR-Agent Pro </p> <p>You can control  the custom labels that will be suggested by the <code>describe</code> tool, from the repo's labels page:</p> <ul> <li>GitHub : go to <code>https://github.com/{owner}/{repo}/labels</code> (or click on the \"Labels\" tab in the issues or PRs page)</li> <li>GitLab : go to <code>https://gitlab.com/{owner}/{repo}/-/labels</code> (or click on \"Manage\" -&gt; \"Labels\" on the left menu)</li> </ul> <p>Now add/edit the custom labels. they should be formatted as follows: * Label name: The name of the custom label. * Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>.</p> <p>The description should be comprehensive and detailed, indicating when to add the desired label. For example: </p>"},{"location":"tools/describe/#markers-template","title":"Markers template","text":"<p>To enable markers, set <code>pr_description.use_description_markers=true</code>. Markers enable to easily integrate user's content and auto-generated content, with a template-like mechanism.</p> <p>For example, if the PR original description was: <pre><code>User content...\n\n## PR Type:\npr_agent:type\n\n## PR Description:\npr_agent:summary\n\n## PR Walkthrough:\npr_agent:walkthrough\n</code></pre> The marker <code>pr_agent:type</code> will be replaced with the PR type, <code>pr_agent:summary</code> will be replaced with the PR summary, and <code>pr_agent:walkthrough</code> will be replaced with the PR walkthrough.</p> <p> \u2192 </p>"},{"location":"tools/describe/#configuration-params","title":"Configuration params:","text":"<ul> <li><code>use_description_markers</code>: if set to true, the tool will use markers template. It replaces every marker of the form <code>pr_agent:marker_name</code> with the relevant content. Default is false.</li> <li><code>include_generated_by_header</code>: if set to true, the tool will add a dedicated header: 'Generated by PR Agent at ...' to any automatic content. Default is true.</li> </ul>"},{"location":"tools/describe/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/describe/#automation","title":"Automation","text":"<ul> <li>When you first install the app, the default mode for the describe tool is: <pre><code>pr_commands = [\"/describe --pr_description.add_original_user_description=true\" \n                         \"--pr_description.keep_original_user_title=true\", ...]\n</code></pre> meaning the <code>describe</code> tool will run automatically on every PR, will keep the original title, and will add the original user description above the generated description.   This default settings aim to strike a good balance between automation and control: If you want more automation, just give the PR a title, and the tool will auto-write a full description; If you want more control, you can add a detailed description, and the tool will add the complementary description below it.</li> <li>For maximal automation, you can change the default mode to: <pre><code>pr_commands = [\"/describe --pr_description.add_original_user_description=false\" \n                         \"--pr_description.keep_original_user_title=true\", ...]\n</code></pre> so the title will be auto-generated as well.</li> <li>Markers are an alternative way to control the generated description, to give maximal control to the user. If you set: <pre><code>pr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n</code></pre> the tool will replace every marker of the form <code>pr_agent:marker_name</code> in the PR description with the relevant content, where <code>marker_name</code> is one of the following:</li> <li><code>type</code>: the PR type.</li> <li><code>summary</code>: the PR summary.</li> <li><code>walkthrough</code>: the PR walkthrough.</li> </ul> <p>Note that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.</p>"},{"location":"tools/describe/#custom-labels","title":"Custom labels","text":"<p>The default labels of the describe tool are quite generic, since they are meant to be used in any repo: [<code>Bug fix</code>, <code>Tests</code>, <code>Enhancement</code>, <code>Documentation</code>, <code>Other</code>].</p> <p>If you specify custom labels in the repo's labels page, you can get tailored labels for your use cases. Examples for custom labels: - <code>Main topic:performance</code> -  pr_agent:The main topic of this PR is performance - <code>New endpoint</code> -  pr_agent:A new endpoint was added in this PR - <code>SQL query</code> -  pr_agent:A new SQL query was added in this PR - <code>Dockerfile changes</code> - pr_agent:The PR contains changes in the Dockerfile - ...</p> <p>The list above is eclectic, and aims to give an idea of different possibilities. Define custom labels that are relevant for your repo and use cases. Note that Labels are not mutually exclusive, so you can add multiple label categories. Make sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it.</p>"},{"location":"tools/documentation/","title":"\ud83d\udc8e Documentation","text":""},{"location":"tools/documentation/#overview","title":"Overview","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically suggests documentation for any code components that changed in the PR (functions, classes, etc.).</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/add_docs\n</code></pre> For example:</p> <p></p> <p></p> <p></p>"},{"location":"tools/documentation/#configuration-options","title":"Configuration options","text":"<ul> <li><code>docs_style</code>: The exact style of the documentation (for python docstring). you can choose between: <code>google</code>, <code>numpy</code>, <code>sphinx</code>, <code>restructuredtext</code>, <code>plain</code>. Default is <code>sphinx</code>.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> </ul> <p>Notes</p> <ul> <li>Language that are currently fully supported: Python, Java, C++, JavaScript, TypeScript.</li> <li>For languages that are not fully supported, the tool will suggest documentation only for new components in the PR.</li> <li>A previous version of the tool, that offered support only for new components, was deprecated.</li> </ul>"},{"location":"tools/improve/","title":"Improve","text":""},{"location":"tools/improve/#overview","title":"Overview","text":"<p>The <code>improve</code> tool scans the PR code changes, and automatically generates suggestions for improving the PR code. The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/improve\n</code></pre></p>"},{"location":"tools/improve/#summarized-vs-committable-code-suggestions","title":"Summarized vs committable code suggestions","text":"<p>The code suggestions can be presented as a single comment (via <code>pr_code_suggestions.summarize=true</code>):</p> <p></p> <p>Or as a separate commitable code comment for each suggestion:</p> <p></p> <p>Note that a single comment has a significantly smaller PR footprint. We recommend this mode for most cases. Also note that collapsible are not supported in Bitbucket. Hence, the suggestions are presented there as code comments.</p>"},{"location":"tools/improve/#extended-mode","title":"Extended mode","text":"<p>An extended mode, which does not involve PR Compression and provides more comprehensive suggestions, can be invoked by commenting on any PR: <pre><code>/improve --extended\n</code></pre></p> <p>or by setting: <pre><code>[pr_code_suggestions]\nauto_extended_mode=true\n</code></pre> (True by default).</p> <p>Note that the extended mode divides the PR code changes into chunks, up to the token limits, where each chunk is handled separately (might use multiple calls to GPT-4 for large PRs). Hence, the total number of suggestions is proportional to the number of chunks, i.e., the size of the PR.</p>"},{"location":"tools/improve/#configuration-options","title":"Configuration options","text":"<p>To edit configurations related to the improve tool (<code>pr_code_suggestions</code> section), use the following template: <pre><code>/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n</code></pre></p>"},{"location":"tools/improve/#general-options","title":"General options","text":"<ul> <li><code>num_code_suggestions</code>: number of code suggestions provided by the 'improve' tool. Default is 4.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> <li><code>rank_suggestions</code>: if set to true, the tool will rank the suggestions, based on importance. Default is false.</li> <li><code>summarize</code>: if set to true, the tool will display the suggestions in a single comment. Default is false.</li> <li><code>enable_help_text</code>: if set to true, the tool will display a help text in the comment. Default is true.</li> </ul>"},{"location":"tools/improve/#params-for-improve-extended-mode","title":"params for '/improve --extended' mode","text":"<ul> <li><code>auto_extended_mode</code>: enable extended mode automatically (no need for the <code>--extended</code> option). Default is true.</li> <li><code>num_code_suggestions_per_chunk</code>: number of code suggestions provided by the 'improve' tool, per chunk. Default is 8.</li> <li><code>rank_extended_suggestions</code>: if set to true, the tool will rank the suggestions, based on importance. Default is true.</li> <li><code>max_number_of_calls</code>: maximum number of chunks. Default is 5.</li> <li><code>final_clip_factor</code>: factor to remove suggestions with low confidence. Default is 0.9.</li> </ul>"},{"location":"tools/improve/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/improve/#extra-instructions","title":"Extra instructions","text":"<p>Extra instructions are very important for the <code>imrpove</code> tool, since they enable you to guide the model to suggestions that are more relevant to the specific needs of the project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify relevant aspects that you want the model to focus on.</p> <p>Examples for extra instructions: <pre><code>[pr_code_suggestions] # /improve #\nextra_instructions=\"\"\"\nEmphasize the following aspects:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.</p>"},{"location":"tools/improve/#a-note-on-code-suggestions-quality","title":"A note on code suggestions quality","text":"<ul> <li>While the current AI for code is getting better and better (GPT-4), it's not flawless. Not all the suggestions will be perfect, and a user should not accept all of them automatically.</li> <li>Suggestions are not meant to be simplistic. Instead, they aim to give deep feedback and raise questions, ideas and thoughts to the user, who can then use his judgment, experience, and understanding of the code base.</li> <li>Recommended to use the <code>exra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.</li> <li>Consider also trying the Custom Suggestions Tool \ud83d\udc8e, that will only propose suggestions that follow specific guidelines defined by user.</li> </ul>"},{"location":"tools/review/","title":"Review","text":""},{"location":"tools/review/#overview","title":"Overview","text":"<p>The <code>review</code> tool scans the PR code changes, and automatically generates a PR review. The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on any PR: <pre><code>/review\n</code></pre> For example:</p> <p></p> <p></p>"},{"location":"tools/review/#configuration-options","title":"Configuration options","text":"<p>To edit configurations  related to the review tool (<code>pr_reviewer</code> section), use the following template: <pre><code>/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n</code></pre></p>"},{"location":"tools/review/#general-options","title":"General options","text":"<ul> <li><code>num_code_suggestions</code>: number of code suggestions provided by the 'review' tool. For manual comments, default is 4. For PR-Agent app auto tools, default is 0, meaning no code suggestions will be provided by the review tool, unless you manually edit <code>pr_commands</code>.</li> <li><code>inline_code_comments</code>: if set to true, the tool will publish the code suggestions as comments on the code diff. Default is false.</li> <li><code>persistent_comment</code>: if set to true, the review comment will be persistent, meaning that every new review request will edit the previous one. Default is true.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> </ul>"},{"location":"tools/review/#enabledisable-features","title":"Enable\\disable features","text":"<ul> <li><code>require_focused_review</code>: if set to true, the tool will add a section - 'is the PR a focused one'. Default is false.</li> <li><code>require_score_review</code>: if set to true, the tool will add a section that scores the PR. Default is false.</li> <li><code>require_tests_review</code>: if set to true, the tool will add a section that checks if the PR contains tests. Default is true.</li> <li><code>require_estimate_effort_to_review</code>: if set to true, the tool will add a section that estimates the effort needed to review the PR. Default is true.</li> </ul>"},{"location":"tools/review/#soc2-ticket-compliance","title":"SOC2 ticket compliance \ud83d\udc8e","text":"<p>This feature is available only in PR-Agent Pro </p> <p>This sub-tool checks if the PR description properly contains a ticket to a project management system (e.g., Jira, Asana, Trello, etc.), as required by SOC2 compliance. If not, it will add a label to the PR: \"Missing SOC2 ticket\". - <code>require_soc2_ticket</code>: If set to true, the SOC2 ticket checker sub-tool will be enabled. Default is false. - <code>soc2_ticket_prompt</code>: The prompt for the SOC2 ticket review. Default is: <code>Does the PR description include a link to ticket in a project management system (e.g., Jira, Asana, Trello, etc.) ?</code>. Edit this field if your compliance requirements are different.</p>"},{"location":"tools/review/#adding-pr-labels","title":"Adding PR labels","text":"<ul> <li><code>enable_review_labels_security</code>: if set to true, the tool will publish a 'possible security issue' label if it detects a security issue. Default is true.</li> <li><code>enable_review_labels_effort</code>: if set to true, the tool will publish a 'Review effort [1-5]: x' label. Default is true.</li> </ul>"},{"location":"tools/review/#auto-approval","title":"Auto-approval","text":"<ul> <li><code>enable_auto_approval</code>: if set to true, the tool will approve the PR when invoked with the 'auto_approve' command. Default is false. This flag can be changed only from configuration file.</li> <li><code>maximal_review_effort</code>: maximal effort level for auto-approval. If the PR's estimated review effort is above this threshold, the auto-approval will not run. Default is 5.</li> </ul>"},{"location":"tools/review/#incremental-mode","title":"Incremental Mode","text":"<p>Incremental review only considers changes since the last PR-Agent review. This can be useful when working on the PR in an iterative manner, and you want to focus on the changes since the last review instead of reviewing the entire PR again. For invoking the incremental mode, the following command can be used: <pre><code>/review -i\n</code></pre> Note that the incremental mode is only available for GitHub.</p> <p></p> <p>Under the section 'pr_reviewer', the configuration file contains options to customize the 'review -i' tool. These configurations can be used to control the rate at which the incremental review tool will create new review comments when invoked automatically, to prevent making too much noise in the PR. - <code>minimal_commits_for_incremental_review</code>: Minimal number of commits since the last review that are required to create incremental review. If there are less than the specified number of commits since the last review, the tool will not perform any action. Default is 0 - the tool will always run, no matter how many commits since the last review. - <code>minimal_minutes_for_incremental_review</code>: Minimal number of minutes that need to pass since the last reviewed commit to create incremental review. If less than the specified number of minutes have passed between the last reviewed commit and running this command, the tool will not perform any action.  Default is 0 - the tool will always run, no matter how much time have passed since the last reviewed commit. - <code>require_all_thresholds_for_incremental_review</code>: If set to true, all the previous thresholds must be met for incremental review to run. If false, only one is enough to run the tool. For example, if <code>minimal_commits_for_incremental_review=2</code> and <code>minimal_minutes_for_incremental_review=2</code>, and we have 3 commits since the last review, but the last reviewed commit is from 1 minute ago: When <code>require_all_thresholds_for_incremental_review=true</code> the incremental review will not run, because only 1 out of 2 conditions were met (we have enough commits but the last review is too recent), but when <code>require_all_thresholds_for_incremental_review=false</code> the incremental review will run, because one condition is enough (we have 3 commits which is more than the configured 2). Default is false - the tool will run as long as at least once conditions is met.</p>"},{"location":"tools/review/#pr-reflection","title":"PR Reflection","text":"<p>By invoking: <pre><code>/reflect_and_review\n</code></pre> The tool will first ask the author questions about the PR, and will guide the review based on their answers.</p> <p></p> <p></p> <p></p>"},{"location":"tools/review/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/review/#general-guidelines","title":"General guidelines","text":"<p>The <code>review</code> tool provides a collection of possible feedbacks about a PR. It is recommended to review the Configuration options section, and choose the relevant options for your use case.</p> <p>Some of the features that are disabled by default are quite useful, and should be considered for enabling. For example:  <code>require_score_review</code>, <code>require_soc2_ticket</code>, and more.</p> <p>On the other hand, if you find one of the enabled features to be irrelevant for your use case, disable it. No default configuration can fit all use cases.</p>"},{"location":"tools/review/#code-suggestions","title":"Code suggestions","text":"<p>If you set <code>num_code_suggestions</code>&gt;0 , the <code>review</code> tool will also provide code suggestions.</p> <p>Notice If you are interested only in the code suggestions, it is recommended to use the <code>improve</code> feature instead, since it is a dedicated only to code suggestions, and usually gives better results. Use the <code>review</code> tool if you want to get more comprehensive feedback, which includes code suggestions as well.</p>"},{"location":"tools/review/#automation","title":"Automation","text":"<ul> <li>When you first install the app, the default mode for the <code>review</code> tool is: <pre><code>pr_commands = [\"/review\", ...]\n</code></pre> Meaning the <code>review</code> tool will run automatically on every PR, with the default configuration. Edit this field to enable/disable the tool, or to change the used configurations.</li> </ul>"},{"location":"tools/review/#auto-labels","title":"Auto-labels","text":"<p>The <code>review</code> tool can auto-generate two specific types of labels for a PR:</p> <ul> <li>a <code>possible security issue</code> label that detects a possible security issue (<code>enable_review_labels_security</code> flag)</li> <li>a <code>Review effort [1-5]: x</code> label, where x is the estimated effort to review the PR (<code>enable_review_labels_effort</code> flag)</li> </ul> <p>Both modes are useful, and we recommended to enable them.</p>"},{"location":"tools/review/#extra-instructions","title":"Extra instructions","text":"<p>Extra instructions are important. The <code>review</code> tool can be configured with extra instructions, which can be used to guide the model to a feedback tailored to the needs of your project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify the relevant sub-tool, and the relevant aspects of the PR that you want to emphasize.</p> <p>Examples for extra instructions: <pre><code>[pr_reviewer] # /review #\nextra_instructions=\"\"\"\nIn the code feedback section, emphasize the following:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.</p>"},{"location":"tools/review/#auto-approval_1","title":"Auto-approval","text":"<p>PR-Agent can approve a PR when a specific comment is invoked.</p> <p>To ensure safety, the auto-approval feature is disabled by default. To enable auto-approval, you need to actively set in a pre-defined configuration file the following: <pre><code>[pr_reviewer]\nenable_auto_approval = true\n</code></pre> (this specific flag cannot be set with a command line argument, only in the configuration file, committed to the repository)</p> <p>After enabling, by commenting on a PR: <pre><code>/review auto_approve\n</code></pre> PR-Agent will automatically approve the PR, and add a comment with the approval.</p> <p>You can also enable auto-approval only if the PR meets certain requirements, such as that the <code>estimated_review_effort</code> label is equal or below a certain threshold, by adjusting the flag: <pre><code>[pr_reviewer]\nmaximal_review_effort = 5\n</code></pre></p>"},{"location":"tools/similar_issues/","title":"Similar Issues","text":""},{"location":"tools/similar_issues/#overview","title":"Overview","text":"<p>The similar issue tool retrieves the most similar issues to the current issue. It can be invoked manually by commenting on any PR: <pre><code>/similar_issue\n</code></pre> For example:</p> <p></p> <p></p> <p></p> <p>Note that to perform retrieval, the <code>similar_issue</code> tool indexes all the repo previous issues (once).</p> <p>Select VectorDBs by changing <code>pr_similar_issue</code> parameter in <code>configuration.toml</code> file </p> <p>2 VectorDBs are available to switch in 1. LanceDB 2. Pinecone</p> <p>To enable usage of the 'similar issue' tool for Pinecone, you need to set the following keys in <code>.secrets.toml</code> (or in the relevant environment variables):</p> <p><pre><code>[pinecone]\napi_key = \"...\"\nenvironment = \"...\"\n</code></pre> These parameters can be obtained by registering to Pinecone.</p>"},{"location":"tools/similar_issues/#how-to-use","title":"How to use:","text":"<ul> <li> <p>To invoke the 'similar issue' tool from CLI, run: <code>python3 cli.py --issue_url=... similar_issue</code></p> </li> <li> <p>To invoke the 'similar' issue tool via online usage, comment on a PR: <code>/similar_issue</code></p> </li> <li> <p>You can also enable the 'similar issue' tool to run automatically when a new issue is opened, by adding it to the pr_commands list in the github_app section</p> </li> </ul>"},{"location":"tools/test/","title":"\ud83d\udc8e Test","text":""},{"location":"tools/test/#overview","title":"Overview","text":"<p>By combining LLM abilities with static code analysis, the <code>test</code> tool  generate tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR: <pre><code>/test component_name\n</code></pre> where 'component_name' is the name of a specific component in the PR. To get a list of the components that changed in the PR, use the <code>analyze</code> tool.</p> <p>An example result:</p> <p></p> <p></p> <p></p> <p>Notes - Language that are currently supported by the tool: Python, Java, C++, JavaScript, TypeScript.</p>"},{"location":"tools/test/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_tests</code>: number of tests to generate. Default is 3.</li> <li><code>testing_framework</code>: the testing framework to use. If not set, for Python it will use <code>pytest</code>, for Java it will use <code>JUnit</code>, for C++ it will use <code>Catch2</code>, and for JavaScript and TypeScript it will use <code>jest</code>.</li> <li><code>avoid_mocks</code>: if set to true, the tool will try to avoid using mocks in the generated tests. Note that even if this option is set to true, the tool might still use mocks if it cannot generate a test without them. Default is true.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"use the following mock injection scheme: ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> <li><code>enable_help_text</code>: if set to true, the tool will add a help text to the PR comment. Default is true.</li> </ul>"},{"location":"tools/update_changelog/","title":"Update Changelog","text":""},{"location":"tools/update_changelog/#overview","title":"Overview","text":"<p>The <code>update_changelog</code> tool automatically updates the CHANGELOG.md file with the PR changes. It can be invoked manually by commenting on any PR: <pre><code>/update_changelog\n</code></pre> For example:</p> <p></p> <p></p>"},{"location":"tools/update_changelog/#configuration-options","title":"Configuration options","text":"<p>Under the section 'pr_update_changelog', the configuration file contains options to customize the 'update changelog' tool:</p> <ul> <li><code>push_changelog_changes</code>: whether to push the changes to CHANGELOG.md, or just print them. Default is false (print only).</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...</li> </ul>"},{"location":"usage-guide/","title":"Usage guide","text":"<ul> <li>Introduction</li> <li>Configuration Options</li> <li>Managing Mail Notifications</li> <li>Usage and Automation<ul> <li>Local Repo (CLI)</li> <li>Online Usage</li> <li>GitHub App</li> <li>GitHub Action</li> <li>GitLab Webhook</li> <li>BitBucket App</li> <li>Azure DevOps Provider</li> </ul> </li> <li>Additional Configurations Walkthrough<ul> <li>Ignoring files from analysis</li> <li>Extra instructions</li> <li>Working with large PRs</li> <li>Changing a model</li> <li>Patch Extra Lines</li> <li>Editing the prompts</li> </ul> </li> </ul>"},{"location":"usage-guide/additional_configurations/","title":"Additional Configurations","text":""},{"location":"usage-guide/additional_configurations/#ignoring-files-from-analysis","title":"Ignoring files from analysis","text":"<p>In some cases, you may want to exclude specific files or directories from the analysis performed by CodiumAI PR-Agent. This can be useful, for example, when you have files that are generated automatically or files that shouldn't be reviewed, like vendored code.</p> <p>To ignore files or directories, edit the ignore.toml configuration file. This setting also exposes the following environment variables:</p> <ul> <li><code>IGNORE.GLOB</code></li> <li><code>IGNORE.REGEX</code></li> </ul> <p>For example, to ignore python files in a PR with online usage, comment on a PR: <code>/review --ignore.glob=['*.py']</code></p> <p>To ignore python files in all PRs, set in a configuration file: <pre><code>[ignore]\nglob = ['*.py']\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#extra-instructions","title":"Extra instructions","text":"<p>All PR-Agent tools have a parameter called <code>extra_instructions</code>, that enables to add free-text extra instructions. Example usage: <pre><code>/update_changelog --pr_update_changelog.extra_instructions=\"Make sure to update also the version ...\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#working-with-large-prs","title":"Working with large PRs","text":"<p>The default mode of CodiumAI is to have a single call per tool, using GPT-4, which has a token limit of 8000 tokens. This mode provide a very good speed-quality-cost tradeoff, and can handle most PRs successfully. When the PR is above the token limit, it employs a PR Compression strategy.</p> <p>However, for very large PRs, or in case you want to emphasize quality over speed and cost, there are 2 possible solutions: 1) Use a model with larger context, like GPT-32K, or claude-100K. This solution will be applicable for all the tools. 2) For the <code>/improve</code> tool, there is an 'extended' mode (<code>/improve --extended</code>), which divides the PR to chunks, and process each chunk separately. With this mode, regardless of the model, no compression will be done (but for large PRs, multiple model calls may occur)</p>"},{"location":"usage-guide/additional_configurations/#changing-a-model","title":"Changing a model","text":"<p>See here for the list of available models. To use a different model than the default (GPT-4), you need to edit configuration file. For models and environments not from OPENAI, you might need to provide additional keys and other parameters. See below for instructions.</p>"},{"location":"usage-guide/additional_configurations/#azure","title":"Azure","text":"<p>To use Azure, set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action): <pre><code>[openai]\nkey = \"\" # your azure api key\napi_type = \"azure\"\napi_version = '2023-05-15'  # Check Azure documentation for the current API version\napi_base = \"\"  # The base URL for your Azure OpenAI resource. e.g. \"https://&lt;your resource name&gt;.openai.azure.com\"\ndeployment_id = \"\"  # The deployment name you chose when you deployed the engine\n</code></pre></p> <p>and set in your configuration file: <pre><code>[config]\nmodel=\"\" # the OpenAI model you've deployed on Azure (e.g. gpt-3.5-turbo)\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#huggingface","title":"Huggingface","text":"<p>Local You can run Huggingface models locally through either VLLM or Ollama</p> <p>E.g. to use a new Huggingface model locally via Ollama, set: <pre><code>[__init__.py]\nMAX_TOKENS = {\n    \"model-name-on-ollama\": &lt;max_tokens&gt;\n}\ne.g.\nMAX_TOKENS={\n    ...,\n    \"ollama/llama2\": 4096\n}\n\n\n[config] # in configuration.toml\nmodel = \"ollama/llama2\"\n\n[ollama] # in .secrets.toml\napi_base = ... # the base url for your huggingface inference endpoint\n# e.g. if running Ollama locally, you may use:\napi_base = \"http://localhost:11434/\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#inference-endpoints","title":"Inference Endpoints","text":"<p>To use a new model with Huggingface Inference Endpoints, for example, set: <pre><code>[__init__.py]\nMAX_TOKENS = {\n    \"model-name-on-huggingface\": &lt;max_tokens&gt;\n}\ne.g.\nMAX_TOKENS={\n    ...,\n    \"meta-llama/Llama-2-7b-chat-hf\": 4096\n}\n[config] # in configuration.toml\nmodel = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\n\n[huggingface] # in .secrets.toml\nkey = ... # your huggingface api key\napi_base = ... # the base url for your huggingface inference endpoint\n</code></pre> (you can obtain a Llama2 key from here)</p>"},{"location":"usage-guide/additional_configurations/#replicate","title":"Replicate","text":"<p>To use Llama2 model with Replicate, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\n[replicate] # in .secrets.toml\nkey = ...\n</code></pre> (you can obtain a Llama2 key from here)</p> <p>Also review the AiHandler file for instruction how to set keys for other models.</p>"},{"location":"usage-guide/additional_configurations/#vertex-ai","title":"Vertex AI","text":"<p>To use Google's Vertex AI platform and its associated models (chat-bison/codechat-bison) set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"vertex_ai/codechat-bison\"\nfallback_models=\"vertex_ai/codechat-bison\"\n\n[vertexai] # in .secrets.toml\nvertex_project = \"my-google-cloud-project\"\nvertex_location = \"\"\n</code></pre> <p>Your application default credentials will be used for authentication so there is no need to set explicit credentials in most environments.</p> <p>If you do want to set explicit credentials then you can use the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable set to a path to a json credentials file.</p>"},{"location":"usage-guide/additional_configurations/#anthropic","title":"Anthropic","text":"<p>To use Anthropic models, set the relevant models in the configuration section of the configuration file: <pre><code>[config]\nmodel=\"anthropic/claude-3-opus-20240229\"\nmodel_turbo=\"anthropic/claude-3-opus-20240229\"\nfallback_models=[\"anthropic/claude-3-opus-20240229\"]\n</code></pre></p> <p>And also set the api key in the .secrets.toml file: <pre><code>[anthropic]\nKEY = \"...\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#amazon-bedrock","title":"Amazon Bedrock","text":"<p>To use Amazon Bedrock and its foundational models, add the below configuration:</p> <pre><code>[config] # in configuration.toml\nmodel = \"anthropic.claude-v2\"\nfallback_models=\"anthropic.claude-instant-v1\"\n\n[aws] # in .secrets.toml\nbedrock_region = \"us-east-1\"\n</code></pre> <p>Note that you have to add access to foundational models before using them. Please refer to this document for more details.</p> <p>AWS session is automatically authenticated from your environment, but you can also explicitly set <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p>"},{"location":"usage-guide/additional_configurations/#patch-extra-lines","title":"Patch Extra Lines","text":"<p>By default, around any change in your PR, git patch provides 3 lines of context above and below the change. <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n</code></pre></p> <p>For the <code>review</code>, <code>describe</code>, <code>ask</code> and <code>add_docs</code> tools, if the token budget allows, PR-Agent tries to increase the number of lines of context, via the parameter: <pre><code>[config]\npatch_extra_lines=3\n</code></pre></p> <p>Increasing this number provides more context to the model, but will also increase the token budget. If the PR is too large (see PR Compression strategy), PR-Agent automatically sets this number to 0, using the original git patch.</p>"},{"location":"usage-guide/additional_configurations/#editing-the-prompts","title":"Editing the prompts","text":"<p>The prompts for the various PR-Agent tools are defined in the <code>pr_agent/settings</code> folder. In practice, the prompts are loaded and stored as a standard setting object. Hence, editing them is similar to editing any other configuration value - just place the relevant key in <code>.pr_agent.toml</code>file, and override the default value.</p> <p>For example, if you want to edit the prompts of the describe tool, you can add the following to your <code>.pr_agent.toml</code> file: <pre><code>[pr_description_prompt]\nsystem=\"\"\"\n...\n\"\"\"\nuser=\"\"\"\n...\n\"\"\"\n</code></pre> Note that the new prompt will need to generate an output compatible with the relevant post-process function.</p>"},{"location":"usage-guide/automations_and_usage/","title":"Usage and Automation","text":""},{"location":"usage-guide/automations_and_usage/#local-repo-cli","title":"Local repo (CLI)","text":"<p>When running from your local repo (CLI), your local configuration file will be used. Examples of invoking the different tools via the CLI:</p> <ul> <li>Review:       <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  review</code></li> <li>Describe:     <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  describe</code></li> <li>Improve:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  improve</code></li> <li>Ask:          <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  ask \"Write me a poem about this PR\"</code></li> <li>Reflect:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  reflect</code></li> <li>Update Changelog:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  update_changelog</code></li> </ul> <p><code>&lt;pr_url&gt;</code> is the url of the relevant PR (for example: #50).</p> <p>Notes:</p> <p>(1) in addition to editing your local configuration file, you can also change any configuration value by adding it to the command line: <pre><code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  /review --pr_reviewer.extra_instructions=\"focus on the file: ...\"\n</code></pre></p> <p>(2) You can print results locally, without publishing them, by setting in <code>configuration.toml</code>: <pre><code>[config]\npublish_output=false\nverbosity_level=2\n</code></pre> This is useful for debugging or experimenting with different tools.</p>"},{"location":"usage-guide/automations_and_usage/#online-usage","title":"Online usage","text":"<p>Online usage means invoking PR-Agent tools by comments on a PR. Commands for invoking the different tools via comments:</p> <ul> <li>Review:       <code>/review</code></li> <li>Describe:     <code>/describe</code></li> <li>Improve:      <code>/improve</code></li> <li>Ask:          <code>/ask \"...\"</code></li> <li>Reflect:      <code>/reflect</code></li> <li>Update Changelog:      <code>/update_changelog</code></li> </ul> <p>To edit a specific configuration value, just add <code>--config_path=&lt;value&gt;</code> to any command. For example, if you want to edit the <code>review</code> tool configurations, you can run: <pre><code>/review --pr_reviewer.extra_instructions=\"...\" --pr_reviewer.require_score_review=false\n</code></pre> Any configuration value in configuration file file can be similarly edited. Comment <code>/config</code> to see the list of available configurations.</p>"},{"location":"usage-guide/automations_and_usage/#github-app","title":"GitHub App","text":""},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened","title":"GitHub app automatic tools when a new PR is opened","text":"<p>The github_app section defines GitHub app specific configurations.  </p> <p>The configuration parameter <code>pr_commands</code> defines the list of tools that will be run automatically when a new PR is opened. <pre><code>[github_app]\npr_commands = [\n    \"/describe --pr_description.add_original_user_description=true --pr_description.keep_original_user_title=true --pr_description.final_update_message=false\",\n    \"/review --pr_reviewer.num_code_suggestions=0 --pr_reviewer.final_update_message=false\",\n    \"/improve\",\n]\n</code></pre> This means that when a new PR is opened/reopened or marked as ready for review, PR-Agent will run the <code>describe</code>, <code>review</code> and <code>improve</code> tools. For the <code>describe</code> tool, for example, the <code>add_original_user_description</code> and <code>keep_original_user_title</code> parameters will be set to true.</p> <p>You can override the default tool parameters by using one the three options for a configuration file: wiki, local, or global.  For example, if your local <code>.pr_agent.toml</code> file contains: <pre><code>[pr_description]\nadd_original_user_description = false\nkeep_original_user_title = false\n</code></pre> When a new PR is opened, PR-Agent will run the <code>describe</code> tool with the above parameters.</p> <p>To cancel the automatic run of all the tools, set: <pre><code>[github_app]\nhandle_pr_actions = []\n</code></pre></p> <p>You can also disable automatic runs for PRs with specific titles, by setting the <code>ignore_pr_titles</code> parameter with the relevant regex. For example: <pre><code>[github_app]\nignore_pr_title = [\"^[Auto]\", \".*ignore.*\"]\n</code></pre> will ignore PRs with titles that start with \"Auto\" or contain the word \"ignore\".</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-for-push-actions-commits-to-an-open-pr","title":"GitHub app automatic tools for push actions (commits to an open PR)","text":"<p>In addition to running automatic tools when a PR is opened, the GitHub app can also respond to new code that is pushed to an open PR.</p> <p>The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the PR. <pre><code>[github_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe --pr_description.add_original_user_description=true --pr_description.keep_original_user_title=true\",\n    \"/review  --pr_reviewer.num_code_suggestions=0\",\n]\n</code></pre> This means that when new code is pushed to the PR, the PR-Agent will run the <code>describe</code> and <code>review</code> tools, with the specified parameters.</p>"},{"location":"usage-guide/automations_and_usage/#github-action","title":"GitHub Action","text":"<p><code>GitHub Action</code> is a different way to trigger PR-Agent tools, and uses a different configuration mechanism than <code>GitHub App</code>. You can configure settings for <code>GitHub Action</code> by adding environment variables under the env section in <code>.github/workflows/pr_agent.yml</code> file.  Specifically, start by setting the following environment variables: <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }} # Make sure to add your OpenAI key to your repo secrets\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Make sure to add your GitHub token to your repo secrets\n        github_action_config.auto_review: \"true\" # enable\\disable auto review\n        github_action_config.auto_describe: \"true\" # enable\\disable auto describe\n        github_action_config.auto_improve: \"true\" # enable\\disable auto improve\n</code></pre> <code>github_action_config.auto_review</code>, <code>github_action_config.auto_describe</code> and <code>github_action_config.auto_improve</code> are used to enable/disable automatic tools that run when a new PR is opened. If not set, the default configuration is for all three tools to run automatically when a new PR is opened.</p> <p>Note that you can give additional config parameters by adding environment variables to <code>.github/workflows/pr_agent.yml</code>, or by using a <code>.pr_agent.toml</code> file in the root of your repo, similar to the GitHub App usage.</p> <p>For example, you can set an environment variable: <code>pr_description.add_original_user_description=false</code>, or add a <code>.pr_agent.toml</code> file with the following content: <pre><code>[pr_description]\nadd_original_user_description = false\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#gitlab-webhook","title":"GitLab Webhook","text":"<p>After setting up a GitLab webhook, to control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App: <pre><code>[gitlab]\npr_commands = [\n    \"/describe --pr_description.add_original_user_description=true --pr_description.keep_original_user_title=true\",\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve\",\n]\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-app","title":"BitBucket App","text":"<p>Similar to GitHub app, when running PR-Agent from BitBucket App, the default configuration file from a pre-built docker will be initially loaded.</p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if your local <code>.pr_agent.toml</code> file contains: <pre><code>[pr_reviewer]\ninline_code_comments = true\n</code></pre></p> <p>Each time you invoke a <code>/review</code> tool, it will use inline code comments.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-self-hosted-app-automatic-tools","title":"BitBucket Self-Hosted App automatic tools","text":"<p>to control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file: Specifically, set the following values:</p> <p>[bitbucket_app] <pre><code>pr_commands = [\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve --pr_code_suggestions.summarize=false\",\n]\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\nuse_repo_settings_file=false\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in experation date, and will use the user identity for API calls.  Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create seperate ADO user identity (via AAD) to the agent.</p> <p>If PAT was choosen, you can assign the value in .secrets.toml.  If DefaultAzureCredential was choosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly,  or use managed identity/az cli (for local develpment) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App: <pre><code>[azure_devops_server]\npr_commands = [\n    \"/describe --pr_description.add_original_user_description=true --pr_description.keep_original_user_title=true\",\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve\",\n]\n</code></pre></p>"},{"location":"usage-guide/configuration_options/","title":"Configuration Options","text":"<p>The different tools and sub-tools used by CodiumAI PR-Agent are adjustable via the configuration file.</p> <p>In addition to general configuration options, each tool has its own configurations. For example, the <code>review</code> tool will use parameters from the pr_reviewer section in the configuration file. See the Tools Guide for a detailed description of the different tools and their configurations.</p> <p>There are three ways to set persistent configurations:</p> <ol> <li>Wiki configuration page \ud83d\udc8e</li> <li>Local configuration file</li> <li>Global configuration file \ud83d\udc8e</li> </ol> <p>In terms of precedence, wiki configurations will override local configurations, and local configurations will override global configurations.</p>"},{"location":"usage-guide/configuration_options/#wiki-configuration-file","title":"Wiki configuration file \ud83d\udc8e","text":"<p>Specifically for GitHub, with PR-Agent-Pro you can set configurations by creating a page called <code>.pr_agent.toml</code> in the wiki of the repo.  The advantage of this method is that it allows to set configurations without needing to commit new content to the repo - just edit the wiki page and save.</p> <p></p> <p>Click here to see a short instructional video. We recommend surrounding the configuration content with triple-quotes, to allow better presentation when displayed in the wiki as markdown. An example content:</p> <pre><code>[pr_description] # /describe #\nkeep_original_user_title=false\n</code></pre> <p>PR-Agent will know to remove the triple-quotes when reading the configuration content.</p>"},{"location":"usage-guide/configuration_options/#local-configuration-file","title":"Local configuration file","text":"<p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if you set in <code>.pr_agent.toml</code>:</p> <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\n- instruction a\n- instruction b\n...\n\"\"\"\n</code></pre> <p>Then you can give a list of extra instructions to the <code>review</code> tool.</p>"},{"location":"usage-guide/configuration_options/#global-configuration-file","title":"Global configuration file \ud83d\udc8e","text":"<p>If you create a repo called <code>pr-agent-settings</code> in your organization, it's configuration file <code>.pr_agent.toml</code> will be used as a global configuration file for any other repo that belongs to the same organization. Parameters from a local <code>.pr_agent.toml</code> file, in a specific repo, will override the global configuration parameters.</p> <p>For example, in the GitHub organization <code>Codium-ai</code>: - The repo <code>https://github.com/Codium-ai/pr-agent-settings</code> contains a <code>.pr_agent.toml</code> file that serves as a global configuration file for all the repos in the GitHub organization <code>Codium-ai</code>. - The repo <code>https://github.com/Codium-ai/pr-agent</code> inherits the global configuration file from <code>pr-agent-settings</code>.</p>"},{"location":"usage-guide/introduction/","title":"Introduction","text":"<p>After installation, there are three basic ways to invoke CodiumAI PR-Agent:</p> <ol> <li>Locally running a CLI command</li> <li>Online usage - by commenting on a PR</li> <li>Enabling PR-Agent tools to run automatically when a new PR is opened</li> </ol> <p>Specifically, CLI commands can be issued by invoking a pre-built docker image, or by invoking a locally cloned repo. For online usage, you will need to setup either a GitHub App, or a GitHub Action. GitHub App and GitHub Action also enable to run PR-Agent specific tool automatically when a new PR is opened.</p> <p>git provider: The git_provider field in the configuration file determines the GIT provider that will be used by PR-Agent. Currently, the following providers are supported: <code>\"github\", \"gitlab\", \"bitbucket\", \"azure\", \"codecommit\", \"local\", \"gerrit\"</code></p>"},{"location":"usage-guide/mail_notifications/","title":"Managing email notifications","text":"<p>Unfortunately, it is not possible in GitHub to disable mail notifications from a specific user. If you are subscribed to notifications for a repo with PR-Agent, we recommend turning off notifications for PR comments, to avoid lengthy emails:</p> <p></p> <p>As an alternative, you can filter in your mail provider the notifications specifically from the PR-Agent bot, see how.</p> <p></p>"}]}